// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: CrossChainTxInfo.proto

//包名，通过protoc生成时go文件时

package go_protos

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type CrossChainTxInfo struct {
	NodeAddr             string                  `protobuf:"bytes,1,opt,name=NodeAddr,proto3" json:"NodeAddr,omitempty"`
	WalletAddr           string                  `protobuf:"bytes,2,opt,name=WalletAddr,proto3" json:"WalletAddr,omitempty"`
	ChainName            string                  `protobuf:"bytes,3,opt,name=ChainName,proto3" json:"ChainName,omitempty"`
	ChainCoinType        uint32                  `protobuf:"varint,4,opt,name=ChainCoinType,proto3" json:"ChainCoinType,omitempty"`
	BlockHeight          uint64                  `protobuf:"varint,5,opt,name=BlockHeight,proto3" json:"BlockHeight,omitempty"`
	BlockHash            string                  `protobuf:"bytes,6,opt,name=BlockHash,proto3" json:"BlockHash,omitempty"`
	TxId                 string                  `protobuf:"bytes,7,opt,name=TxId,proto3" json:"TxId,omitempty"`
	TimeBlock            int64                   `protobuf:"varint,8,opt,name=TimeBlock,proto3" json:"TimeBlock,omitempty"`
	Status               string                  `protobuf:"bytes,9,opt,name=Status,proto3" json:"Status,omitempty"`
	From                 string                  `protobuf:"bytes,10,opt,name=From,proto3" json:"From,omitempty"`
	To                   string                  `protobuf:"bytes,11,opt,name=To,proto3" json:"To,omitempty"`
	ContractAddress      string                  `protobuf:"bytes,12,opt,name=ContractAddress,proto3" json:"ContractAddress,omitempty"`
	Fee                  int64                   `protobuf:"varint,13,opt,name=Fee,proto3" json:"Fee,omitempty"`
	FeeCny               string                  `protobuf:"bytes,14,opt,name=FeeCny,proto3" json:"FeeCny,omitempty"`
	FeeUsd               string                  `protobuf:"bytes,15,opt,name=FeeUsd,proto3" json:"FeeUsd,omitempty"`
	Confirm              int64                   `protobuf:"varint,16,opt,name=Confirm,proto3" json:"Confirm,omitempty"`
	Amount               int64                   `protobuf:"varint,17,opt,name=Amount,proto3" json:"Amount,omitempty"`
	TokenName            string                  `protobuf:"bytes,18,opt,name=TokenName,proto3" json:"TokenName,omitempty"`
	Send                 bool                    `protobuf:"varint,19,opt,name=Send,proto3" json:"Send,omitempty"`
	TimeStamp            int64                   `protobuf:"varint,20,opt,name=TimeStamp,proto3" json:"TimeStamp,omitempty"`
	DocId                int64                   `protobuf:"varint,21,opt,name=DocId,proto3" json:"DocId,omitempty"`
	Type                 string                  `protobuf:"bytes,22,opt,name=Type,proto3" json:"Type,omitempty"`
	Nonce                uint64                  `protobuf:"varint,23,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	Unique               string                  `protobuf:"bytes,24,opt,name=Unique,proto3" json:"Unique,omitempty"`
	UtxoInput            []*CrossChainUtxoAmount `protobuf:"bytes,25,rep,name=UtxoInput,proto3" json:"UtxoInput,omitempty"`
	UtxoOutput           []*CrossChainUtxoAmount `protobuf:"bytes,26,rep,name=UtxoOutput,proto3" json:"UtxoOutput,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *CrossChainTxInfo) Reset()         { *m = CrossChainTxInfo{} }
func (m *CrossChainTxInfo) String() string { return proto.CompactTextString(m) }
func (*CrossChainTxInfo) ProtoMessage()    {}
func (*CrossChainTxInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1decd41cb73c1dc, []int{0}
}
func (m *CrossChainTxInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainTxInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainTxInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainTxInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainTxInfo.Merge(m, src)
}
func (m *CrossChainTxInfo) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainTxInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainTxInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainTxInfo proto.InternalMessageInfo

func (m *CrossChainTxInfo) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

func (m *CrossChainTxInfo) GetWalletAddr() string {
	if m != nil {
		return m.WalletAddr
	}
	return ""
}

func (m *CrossChainTxInfo) GetChainName() string {
	if m != nil {
		return m.ChainName
	}
	return ""
}

func (m *CrossChainTxInfo) GetChainCoinType() uint32 {
	if m != nil {
		return m.ChainCoinType
	}
	return 0
}

func (m *CrossChainTxInfo) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *CrossChainTxInfo) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *CrossChainTxInfo) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *CrossChainTxInfo) GetTimeBlock() int64 {
	if m != nil {
		return m.TimeBlock
	}
	return 0
}

func (m *CrossChainTxInfo) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *CrossChainTxInfo) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *CrossChainTxInfo) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *CrossChainTxInfo) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *CrossChainTxInfo) GetFee() int64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *CrossChainTxInfo) GetFeeCny() string {
	if m != nil {
		return m.FeeCny
	}
	return ""
}

func (m *CrossChainTxInfo) GetFeeUsd() string {
	if m != nil {
		return m.FeeUsd
	}
	return ""
}

func (m *CrossChainTxInfo) GetConfirm() int64 {
	if m != nil {
		return m.Confirm
	}
	return 0
}

func (m *CrossChainTxInfo) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *CrossChainTxInfo) GetTokenName() string {
	if m != nil {
		return m.TokenName
	}
	return ""
}

func (m *CrossChainTxInfo) GetSend() bool {
	if m != nil {
		return m.Send
	}
	return false
}

func (m *CrossChainTxInfo) GetTimeStamp() int64 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

func (m *CrossChainTxInfo) GetDocId() int64 {
	if m != nil {
		return m.DocId
	}
	return 0
}

func (m *CrossChainTxInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CrossChainTxInfo) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *CrossChainTxInfo) GetUnique() string {
	if m != nil {
		return m.Unique
	}
	return ""
}

func (m *CrossChainTxInfo) GetUtxoInput() []*CrossChainUtxoAmount {
	if m != nil {
		return m.UtxoInput
	}
	return nil
}

func (m *CrossChainTxInfo) GetUtxoOutput() []*CrossChainUtxoAmount {
	if m != nil {
		return m.UtxoOutput
	}
	return nil
}

type CrossChainUtxoAmount struct {
	Address              string   `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	Amount               uint64   `protobuf:"varint,2,opt,name=Amount,proto3" json:"Amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CrossChainUtxoAmount) Reset()         { *m = CrossChainUtxoAmount{} }
func (m *CrossChainUtxoAmount) String() string { return proto.CompactTextString(m) }
func (*CrossChainUtxoAmount) ProtoMessage()    {}
func (*CrossChainUtxoAmount) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1decd41cb73c1dc, []int{1}
}
func (m *CrossChainUtxoAmount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainUtxoAmount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainUtxoAmount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainUtxoAmount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainUtxoAmount.Merge(m, src)
}
func (m *CrossChainUtxoAmount) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainUtxoAmount) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainUtxoAmount.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainUtxoAmount proto.InternalMessageInfo

func (m *CrossChainUtxoAmount) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CrossChainUtxoAmount) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func init() {
	proto.RegisterType((*CrossChainTxInfo)(nil), "go_protos.CrossChainTxInfo")
	proto.RegisterType((*CrossChainUtxoAmount)(nil), "go_protos.CrossChainUtxoAmount")
}

func init() { proto.RegisterFile("CrossChainTxInfo.proto", fileDescriptor_f1decd41cb73c1dc) }

var fileDescriptor_f1decd41cb73c1dc = []byte{
	// 497 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0xf9, 0x6b, 0x3c, 0x21, 0x6d, 0x58, 0x42, 0x18, 0x2a, 0x30, 0x56, 0xc5, 0xc1, 0xa7,
	0x20, 0xc1, 0x19, 0xa1, 0xd6, 0x28, 0x6a, 0x2e, 0x41, 0x72, 0x1c, 0x21, 0x71, 0x41, 0x26, 0xde,
	0x36, 0x56, 0xe3, 0xdd, 0x60, 0xaf, 0xa5, 0xf4, 0x05, 0x78, 0x06, 0x1e, 0x89, 0x23, 0x8f, 0x80,
	0xc2, 0x8b, 0xa0, 0x9d, 0x75, 0xec, 0x50, 0x71, 0xe8, 0x29, 0xf3, 0x7d, 0x33, 0xdf, 0x8c, 0xe7,
	0x9b, 0x0d, 0x8c, 0xfc, 0x4c, 0xe6, 0xb9, 0xbf, 0x8a, 0x12, 0x11, 0x6e, 0xa7, 0xe2, 0x4a, 0x8e,
	0x37, 0x99, 0x54, 0x92, 0xd9, 0xd7, 0xf2, 0x0b, 0x45, 0xf9, 0xd9, 0xf7, 0x0e, 0x0c, 0xee, 0x56,
	0xb1, 0x53, 0xe8, 0xce, 0x64, 0xcc, 0xcf, 0xe3, 0x38, 0x43, 0xcb, 0xb5, 0x3c, 0x3b, 0xa8, 0x30,
	0x73, 0x00, 0x3e, 0x45, 0xeb, 0x35, 0x57, 0x94, 0x6d, 0x50, 0xf6, 0x80, 0x61, 0xcf, 0xc1, 0xa6,
	0x56, 0xb3, 0x28, 0xe5, 0xd8, 0xa4, 0x74, 0x4d, 0xb0, 0x57, 0xd0, 0x27, 0xe0, 0xcb, 0x44, 0x84,
	0xb7, 0x1b, 0x8e, 0x2d, 0xd7, 0xf2, 0xfa, 0xc1, 0xbf, 0x24, 0x73, 0xa1, 0x77, 0xb1, 0x96, 0xcb,
	0x9b, 0x4b, 0x9e, 0x5c, 0xaf, 0x14, 0xb6, 0x5d, 0xcb, 0x6b, 0x05, 0x87, 0x94, 0x9e, 0x62, 0x60,
	0x94, 0xaf, 0xb0, 0x63, 0xa6, 0x54, 0x04, 0x63, 0xd0, 0x0a, 0xb7, 0xd3, 0x18, 0x8f, 0x28, 0x41,
	0xb1, 0x56, 0x84, 0x49, 0xca, 0xa9, 0x08, 0xbb, 0xae, 0xe5, 0x35, 0x83, 0x9a, 0x60, 0x23, 0xe8,
	0xcc, 0x55, 0xa4, 0x8a, 0x1c, 0x6d, 0xd2, 0x94, 0x48, 0x77, 0x9a, 0x64, 0x32, 0x45, 0x30, 0x9d,
	0x74, 0xcc, 0x8e, 0xa1, 0x11, 0x4a, 0xec, 0x11, 0xd3, 0x08, 0x25, 0xf3, 0xe0, 0xc4, 0x97, 0x42,
	0x65, 0xd1, 0x92, 0x1c, 0xe0, 0x79, 0x8e, 0x0f, 0x29, 0x79, 0x97, 0x66, 0x03, 0x68, 0x4e, 0x38,
	0xc7, 0x3e, 0x4d, 0xd7, 0xa1, 0x9e, 0x3b, 0xe1, 0xdc, 0x17, 0xb7, 0x78, 0x6c, 0xe6, 0x1a, 0x54,
	0xf2, 0x8b, 0x3c, 0xc6, 0x93, 0x8a, 0x5f, 0xe4, 0x31, 0x43, 0x38, 0xf2, 0xa5, 0xb8, 0x4a, 0xb2,
	0x14, 0x07, 0xd4, 0x65, 0x0f, 0xb5, 0xe2, 0x3c, 0x95, 0x85, 0x50, 0xf8, 0x88, 0x12, 0x25, 0xa2,
	0xbd, 0xe5, 0x0d, 0x37, 0xf7, 0x60, 0xc6, 0xa9, 0x8a, 0xd0, 0xfb, 0xcd, 0xb9, 0x88, 0xf1, 0xb1,
	0x6b, 0x79, 0xdd, 0x80, 0xe2, 0xbd, 0x53, 0x73, 0x15, 0xa5, 0x1b, 0x1c, 0xd6, 0x4e, 0x11, 0xc1,
	0x86, 0xd0, 0xfe, 0x20, 0x97, 0xd3, 0x18, 0x9f, 0x50, 0xc6, 0x00, 0x72, 0x5c, 0x9f, 0x73, 0x54,
	0x3a, 0xae, 0xaf, 0x38, 0x84, 0xf6, 0x4c, 0x8a, 0x25, 0xc7, 0xa7, 0x74, 0x3f, 0x03, 0xf4, 0x77,
	0x2e, 0x44, 0xf2, 0xad, 0xe0, 0x88, 0x66, 0x33, 0x83, 0xd8, 0x3b, 0xb0, 0x17, 0x6a, 0x2b, 0xa7,
	0x62, 0x53, 0x28, 0x7c, 0xe6, 0x36, 0xbd, 0xde, 0x9b, 0x97, 0xe3, 0xea, 0x9d, 0x8e, 0xeb, 0x37,
	0xaa, 0xab, 0xcc, 0x6e, 0x41, 0xad, 0x60, 0xef, 0x01, 0x34, 0xf8, 0x58, 0x28, 0xad, 0x3f, 0xbd,
	0x9f, 0xfe, 0x40, 0x72, 0x76, 0x09, 0xc3, 0xff, 0xd5, 0x68, 0xc7, 0xf7, 0x57, 0x35, 0x7f, 0x85,
	0x3d, 0x3c, 0x70, 0xbc, 0x41, 0x0b, 0x96, 0xe8, 0xe2, 0xc5, 0xcf, 0x9d, 0x63, 0xfd, 0xda, 0x39,
	0xd6, 0xef, 0x9d, 0x63, 0xfd, 0xf8, 0xe3, 0x3c, 0xf8, 0xdc, 0x1b, 0xbf, 0xae, 0xbe, 0xe4, 0x6b,
	0x87, 0x7e, 0xdf, 0xfe, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x31, 0x1b, 0x35, 0xaf, 0x9d, 0x03, 0x00,
	0x00,
}

func (m *CrossChainTxInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainTxInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainTxInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UtxoOutput) > 0 {
		for iNdEx := len(m.UtxoOutput) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UtxoOutput[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.UtxoInput) > 0 {
		for iNdEx := len(m.UtxoInput) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UtxoInput[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.Unique) > 0 {
		i -= len(m.Unique)
		copy(dAtA[i:], m.Unique)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.Unique)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Nonce != 0 {
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.DocId != 0 {
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(m.DocId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.TimeStamp != 0 {
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(m.TimeStamp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Send {
		i--
		if m.Send {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.TokenName) > 0 {
		i -= len(m.TokenName)
		copy(dAtA[i:], m.TokenName)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.TokenName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Amount != 0 {
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Confirm != 0 {
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(m.Confirm))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.FeeUsd) > 0 {
		i -= len(m.FeeUsd)
		copy(dAtA[i:], m.FeeUsd)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.FeeUsd)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.FeeCny) > 0 {
		i -= len(m.FeeCny)
		copy(dAtA[i:], m.FeeCny)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.FeeCny)))
		i--
		dAtA[i] = 0x72
	}
	if m.Fee != 0 {
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(m.Fee))
		i--
		dAtA[i] = 0x68
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x4a
	}
	if m.TimeBlock != 0 {
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(m.TimeBlock))
		i--
		dAtA[i] = 0x40
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0x32
	}
	if m.BlockHeight != 0 {
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.ChainCoinType != 0 {
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(m.ChainCoinType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ChainName) > 0 {
		i -= len(m.ChainName)
		copy(dAtA[i:], m.ChainName)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.ChainName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.WalletAddr) > 0 {
		i -= len(m.WalletAddr)
		copy(dAtA[i:], m.WalletAddr)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.WalletAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeAddr) > 0 {
		i -= len(m.NodeAddr)
		copy(dAtA[i:], m.NodeAddr)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.NodeAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainUtxoAmount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainUtxoAmount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainUtxoAmount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Amount != 0 {
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCrossChainTxInfo(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCrossChainTxInfo(dAtA []byte, offset int, v uint64) int {
	offset -= sovCrossChainTxInfo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CrossChainTxInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovCrossChainTxInfo(uint64(l))
	}
	l = len(m.WalletAddr)
	if l > 0 {
		n += 1 + l + sovCrossChainTxInfo(uint64(l))
	}
	l = len(m.ChainName)
	if l > 0 {
		n += 1 + l + sovCrossChainTxInfo(uint64(l))
	}
	if m.ChainCoinType != 0 {
		n += 1 + sovCrossChainTxInfo(uint64(m.ChainCoinType))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovCrossChainTxInfo(uint64(m.BlockHeight))
	}
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovCrossChainTxInfo(uint64(l))
	}
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovCrossChainTxInfo(uint64(l))
	}
	if m.TimeBlock != 0 {
		n += 1 + sovCrossChainTxInfo(uint64(m.TimeBlock))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCrossChainTxInfo(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovCrossChainTxInfo(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovCrossChainTxInfo(uint64(l))
	}
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovCrossChainTxInfo(uint64(l))
	}
	if m.Fee != 0 {
		n += 1 + sovCrossChainTxInfo(uint64(m.Fee))
	}
	l = len(m.FeeCny)
	if l > 0 {
		n += 1 + l + sovCrossChainTxInfo(uint64(l))
	}
	l = len(m.FeeUsd)
	if l > 0 {
		n += 1 + l + sovCrossChainTxInfo(uint64(l))
	}
	if m.Confirm != 0 {
		n += 2 + sovCrossChainTxInfo(uint64(m.Confirm))
	}
	if m.Amount != 0 {
		n += 2 + sovCrossChainTxInfo(uint64(m.Amount))
	}
	l = len(m.TokenName)
	if l > 0 {
		n += 2 + l + sovCrossChainTxInfo(uint64(l))
	}
	if m.Send {
		n += 3
	}
	if m.TimeStamp != 0 {
		n += 2 + sovCrossChainTxInfo(uint64(m.TimeStamp))
	}
	if m.DocId != 0 {
		n += 2 + sovCrossChainTxInfo(uint64(m.DocId))
	}
	l = len(m.Type)
	if l > 0 {
		n += 2 + l + sovCrossChainTxInfo(uint64(l))
	}
	if m.Nonce != 0 {
		n += 2 + sovCrossChainTxInfo(uint64(m.Nonce))
	}
	l = len(m.Unique)
	if l > 0 {
		n += 2 + l + sovCrossChainTxInfo(uint64(l))
	}
	if len(m.UtxoInput) > 0 {
		for _, e := range m.UtxoInput {
			l = e.Size()
			n += 2 + l + sovCrossChainTxInfo(uint64(l))
		}
	}
	if len(m.UtxoOutput) > 0 {
		for _, e := range m.UtxoOutput {
			l = e.Size()
			n += 2 + l + sovCrossChainTxInfo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CrossChainUtxoAmount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCrossChainTxInfo(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovCrossChainTxInfo(uint64(m.Amount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCrossChainTxInfo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCrossChainTxInfo(x uint64) (n int) {
	return sovCrossChainTxInfo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CrossChainTxInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChainTxInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainTxInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainTxInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainCoinType", wireType)
			}
			m.ChainCoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainCoinType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeBlock", wireType)
			}
			m.TimeBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			m.Fee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCny", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeCny = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeUsd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeUsd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirm", wireType)
			}
			m.Confirm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Confirm |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Send = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocId", wireType)
			}
			m.DocId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DocId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unique = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtxoInput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UtxoInput = append(m.UtxoInput, &CrossChainUtxoAmount{})
			if err := m.UtxoInput[len(m.UtxoInput)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtxoOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UtxoOutput = append(m.UtxoOutput, &CrossChainUtxoAmount{})
			if err := m.UtxoOutput[len(m.UtxoOutput)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChainTxInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainUtxoAmount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChainTxInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainUtxoAmount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainUtxoAmount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChainTxInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChainTxInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCrossChainTxInfo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCrossChainTxInfo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChainTxInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCrossChainTxInfo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCrossChainTxInfo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCrossChainTxInfo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCrossChainTxInfo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCrossChainTxInfo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCrossChainTxInfo = fmt.Errorf("proto: unexpected end of group")
)
