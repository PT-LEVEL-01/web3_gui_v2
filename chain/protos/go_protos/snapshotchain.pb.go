// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: snapshotchain.proto

//包名，通过protoc生成时go文件时

package go_protos

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SnapshotChain struct {
	No              uint64                  `protobuf:"varint,1,opt,name=No,proto3" json:"No,omitempty"`
	StartingBlock   uint64                  `protobuf:"varint,2,opt,name=StartingBlock,proto3" json:"StartingBlock,omitempty"`
	StartBlockTime  uint64                  `protobuf:"varint,3,opt,name=StartBlockTime,proto3" json:"StartBlockTime,omitempty"`
	CurrentBlock    uint64                  `protobuf:"varint,4,opt,name=CurrentBlock,proto3" json:"CurrentBlock,omitempty"`
	PulledStates    uint64                  `protobuf:"varint,5,opt,name=PulledStates,proto3" json:"PulledStates,omitempty"`
	HighestBlock    uint64                  `protobuf:"varint,6,opt,name=HighestBlock,proto3" json:"HighestBlock,omitempty"`
	SyncBlockFinish bool                    `protobuf:"varint,7,opt,name=SyncBlockFinish,proto3" json:"SyncBlockFinish,omitempty"`
	WitnessBackup   *SnapshotWitnessBackup  `protobuf:"bytes,8,opt,name=WitnessBackup,proto3" json:"WitnessBackup,omitempty"`
	WitnessChain    *SnapshotWitnessChain   `protobuf:"bytes,9,opt,name=WitnessChain,proto3" json:"WitnessChain,omitempty"`
	Balance         *SnapshotBalanceManager `protobuf:"bytes,10,opt,name=Balance,proto3" json:"Balance,omitempty"`
	//			transactionManager *TransactionManager //交易管理器
	// history            *BalanceHistory     //
	StopSyncBlock uint32 `protobuf:"varint,11,opt,name=StopSyncBlock,proto3" json:"StopSyncBlock,omitempty"`
	//BlockHeadAndTxs		Temp =11; //收到的区块高度最大的区块
	//	uint64 GroupHeight =12; //最新导入区块的组高度
	CurrentBlockHash     []byte   `protobuf:"bytes,13,opt,name=CurrentBlockHash,proto3" json:"CurrentBlockHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotChain) Reset()         { *m = SnapshotChain{} }
func (m *SnapshotChain) String() string { return proto.CompactTextString(m) }
func (*SnapshotChain) ProtoMessage()    {}
func (*SnapshotChain) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{0}
}
func (m *SnapshotChain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotChain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotChain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotChain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotChain.Merge(m, src)
}
func (m *SnapshotChain) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotChain) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotChain.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotChain proto.InternalMessageInfo

func (m *SnapshotChain) GetNo() uint64 {
	if m != nil {
		return m.No
	}
	return 0
}

func (m *SnapshotChain) GetStartingBlock() uint64 {
	if m != nil {
		return m.StartingBlock
	}
	return 0
}

func (m *SnapshotChain) GetStartBlockTime() uint64 {
	if m != nil {
		return m.StartBlockTime
	}
	return 0
}

func (m *SnapshotChain) GetCurrentBlock() uint64 {
	if m != nil {
		return m.CurrentBlock
	}
	return 0
}

func (m *SnapshotChain) GetPulledStates() uint64 {
	if m != nil {
		return m.PulledStates
	}
	return 0
}

func (m *SnapshotChain) GetHighestBlock() uint64 {
	if m != nil {
		return m.HighestBlock
	}
	return 0
}

func (m *SnapshotChain) GetSyncBlockFinish() bool {
	if m != nil {
		return m.SyncBlockFinish
	}
	return false
}

func (m *SnapshotChain) GetWitnessBackup() *SnapshotWitnessBackup {
	if m != nil {
		return m.WitnessBackup
	}
	return nil
}

func (m *SnapshotChain) GetWitnessChain() *SnapshotWitnessChain {
	if m != nil {
		return m.WitnessChain
	}
	return nil
}

func (m *SnapshotChain) GetBalance() *SnapshotBalanceManager {
	if m != nil {
		return m.Balance
	}
	return nil
}

func (m *SnapshotChain) GetStopSyncBlock() uint32 {
	if m != nil {
		return m.StopSyncBlock
	}
	return 0
}

func (m *SnapshotChain) GetCurrentBlockHash() []byte {
	if m != nil {
		return m.CurrentBlockHash
	}
	return nil
}

type SnapshotWitnessBackup struct {
	Witnesses            []*BackupWitness          `protobuf:"bytes,1,rep,name=Witnesses,proto3" json:"Witnesses,omitempty"`
	WitnessesMap         map[string]*BackupWitness `protobuf:"bytes,2,rep,name=WitnessesMap,proto3" json:"WitnessesMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	VoteCommunity        map[string]*VoteScoreArr  `protobuf:"bytes,3,rep,name=VoteCommunity,proto3" json:"VoteCommunity,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	VoteCommunityList    map[string]*VoteScore     `protobuf:"bytes,4,rep,name=VoteCommunityList,proto3" json:"VoteCommunityList,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Vote                 map[string]*VoteScoreArr  `protobuf:"bytes,5,rep,name=Vote,proto3" json:"Vote,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	VoteList             map[string]*VoteScore     `protobuf:"bytes,6,rep,name=VoteList,proto3" json:"VoteList,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	LightNode            map[string]*VoteScore     `protobuf:"bytes,7,rep,name=LightNode,proto3" json:"LightNode,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Blacklist            map[string]uint64         `protobuf:"bytes,8,rep,name=Blacklist,proto3" json:"Blacklist,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *SnapshotWitnessBackup) Reset()         { *m = SnapshotWitnessBackup{} }
func (m *SnapshotWitnessBackup) String() string { return proto.CompactTextString(m) }
func (*SnapshotWitnessBackup) ProtoMessage()    {}
func (*SnapshotWitnessBackup) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{1}
}
func (m *SnapshotWitnessBackup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotWitnessBackup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotWitnessBackup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotWitnessBackup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotWitnessBackup.Merge(m, src)
}
func (m *SnapshotWitnessBackup) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotWitnessBackup) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotWitnessBackup.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotWitnessBackup proto.InternalMessageInfo

func (m *SnapshotWitnessBackup) GetWitnesses() []*BackupWitness {
	if m != nil {
		return m.Witnesses
	}
	return nil
}

func (m *SnapshotWitnessBackup) GetWitnessesMap() map[string]*BackupWitness {
	if m != nil {
		return m.WitnessesMap
	}
	return nil
}

func (m *SnapshotWitnessBackup) GetVoteCommunity() map[string]*VoteScoreArr {
	if m != nil {
		return m.VoteCommunity
	}
	return nil
}

func (m *SnapshotWitnessBackup) GetVoteCommunityList() map[string]*VoteScore {
	if m != nil {
		return m.VoteCommunityList
	}
	return nil
}

func (m *SnapshotWitnessBackup) GetVote() map[string]*VoteScoreArr {
	if m != nil {
		return m.Vote
	}
	return nil
}

func (m *SnapshotWitnessBackup) GetVoteList() map[string]*VoteScore {
	if m != nil {
		return m.VoteList
	}
	return nil
}

func (m *SnapshotWitnessBackup) GetLightNode() map[string]*VoteScore {
	if m != nil {
		return m.LightNode
	}
	return nil
}

func (m *SnapshotWitnessBackup) GetBlacklist() map[string]uint64 {
	if m != nil {
		return m.Blacklist
	}
	return nil
}

type BackupWitness struct {
	Addr                 []byte   `protobuf:"bytes,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	Puk                  []byte   `protobuf:"bytes,2,opt,name=Puk,proto3" json:"Puk,omitempty"`
	Score                uint64   `protobuf:"varint,3,opt,name=Score,proto3" json:"Score,omitempty"`
	VoteNum              uint64   `protobuf:"varint,4,opt,name=VoteNum,proto3" json:"VoteNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackupWitness) Reset()         { *m = BackupWitness{} }
func (m *BackupWitness) String() string { return proto.CompactTextString(m) }
func (*BackupWitness) ProtoMessage()    {}
func (*BackupWitness) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{2}
}
func (m *BackupWitness) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupWitness) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupWitness.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupWitness) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupWitness.Merge(m, src)
}
func (m *BackupWitness) XXX_Size() int {
	return m.Size()
}
func (m *BackupWitness) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupWitness.DiscardUnknown(m)
}

var xxx_messageInfo_BackupWitness proto.InternalMessageInfo

func (m *BackupWitness) GetAddr() []byte {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *BackupWitness) GetPuk() []byte {
	if m != nil {
		return m.Puk
	}
	return nil
}

func (m *BackupWitness) GetScore() uint64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *BackupWitness) GetVoteNum() uint64 {
	if m != nil {
		return m.VoteNum
	}
	return 0
}

type VoteScoreArr struct {
	VoteScoreArr         []*VoteScore `protobuf:"bytes,1,rep,name=VoteScoreArr,proto3" json:"VoteScoreArr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *VoteScoreArr) Reset()         { *m = VoteScoreArr{} }
func (m *VoteScoreArr) String() string { return proto.CompactTextString(m) }
func (*VoteScoreArr) ProtoMessage()    {}
func (*VoteScoreArr) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{3}
}
func (m *VoteScoreArr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteScoreArr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteScoreArr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteScoreArr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteScoreArr.Merge(m, src)
}
func (m *VoteScoreArr) XXX_Size() int {
	return m.Size()
}
func (m *VoteScoreArr) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteScoreArr.DiscardUnknown(m)
}

var xxx_messageInfo_VoteScoreArr proto.InternalMessageInfo

func (m *VoteScoreArr) GetVoteScoreArr() []*VoteScore {
	if m != nil {
		return m.VoteScoreArr
	}
	return nil
}

type VoteScore struct {
	Witness              []byte   `protobuf:"bytes,1,opt,name=Witness,proto3" json:"Witness,omitempty"`
	Addr                 []byte   `protobuf:"bytes,2,opt,name=Addr,proto3" json:"Addr,omitempty"`
	Scores               uint64   `protobuf:"varint,3,opt,name=Scores,proto3" json:"Scores,omitempty"`
	Vote                 uint64   `protobuf:"varint,4,opt,name=Vote,proto3" json:"Vote,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VoteScore) Reset()         { *m = VoteScore{} }
func (m *VoteScore) String() string { return proto.CompactTextString(m) }
func (*VoteScore) ProtoMessage()    {}
func (*VoteScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{4}
}
func (m *VoteScore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteScore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteScore.Merge(m, src)
}
func (m *VoteScore) XXX_Size() int {
	return m.Size()
}
func (m *VoteScore) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteScore.DiscardUnknown(m)
}

var xxx_messageInfo_VoteScore proto.InternalMessageInfo

func (m *VoteScore) GetWitness() []byte {
	if m != nil {
		return m.Witness
	}
	return nil
}

func (m *VoteScore) GetAddr() []byte {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *VoteScore) GetScores() uint64 {
	if m != nil {
		return m.Scores
	}
	return 0
}

func (m *VoteScore) GetVote() uint64 {
	if m != nil {
		return m.Vote
	}
	return 0
}

type SnapshotBalanceManager struct {
	CountTotal uint64 `protobuf:"varint,1,opt,name=CountTotal,proto3" json:"CountTotal,omitempty"`
	// BlockHeadAndTxs		SyncBlockHead = 2; //正在同步的余额，准备导入到余额中
	NodeWitness      *TxItem                 `protobuf:"bytes,2,opt,name=NodeWitness,proto3" json:"NodeWitness,omitempty"`
	WitnessVote      map[string]uint64       `protobuf:"bytes,3,rep,name=WitnessVote,proto3" json:"WitnessVote,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DepositCommunity map[string]*DepositInfo `protobuf:"bytes,4,rep,name=DepositCommunity,proto3" json:"DepositCommunity,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DepositLight     map[string]*DepositInfo `protobuf:"bytes,5,rep,name=DepositLight,proto3" json:"DepositLight,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DepositVote      map[string]*DepositInfo `protobuf:"bytes,6,rep,name=DepositVote,proto3" json:"DepositVote,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CommunityVote    map[string]uint64       `protobuf:"bytes,7,rep,name=CommunityVote,proto3" json:"CommunityVote,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	WitnessBackup    *SnapshotWitnessBackup  `protobuf:"bytes,8,opt,name=WitnessBackup,proto3" json:"WitnessBackup,omitempty"`
	AddBlockNum      map[string]uint64       `protobuf:"bytes,9,rep,name=AddBlockNum,proto3" json:"AddBlockNum,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	AddBlockReward   map[string]uint64       `protobuf:"bytes,10,rep,name=AddBlockReward,proto3" json:"AddBlockReward,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	BlockIndex       map[string]uint64       `protobuf:"bytes,11,rep,name=BlockIndex,proto3" json:"BlockIndex,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// cacheTxLockLock *sync.RWMutex
	// cacheTxlock     []*TxItr
	//
	//		cacheTxlock  *sync.Map //key:string=转出地址;value:*TxList=;
	//	eventBus     event.EventBus
	WitnessRatio         map[string]uint64       `protobuf:"bytes,12,rep,name=WitnessRatio,proto3" json:"WitnessRatio,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	LastDistributeHeight uint64                  `protobuf:"varint,13,opt,name=LastDistributeHeight,proto3" json:"LastDistributeHeight,omitempty"`
	WitnessRewardPool    map[string][]byte       `protobuf:"bytes,14,rep,name=WitnessRewardPool,proto3" json:"WitnessRewardPool,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CommunityRewardPool  map[string][]byte       `protobuf:"bytes,15,rep,name=CommunityRewardPool,proto3" json:"CommunityRewardPool,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NameNetRewardPool    map[string][]byte       `protobuf:"bytes,16,rep,name=NameNetRewardPool,proto3" json:"NameNetRewardPool,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	WitnessMapCommunitys map[string]*Addresses   `protobuf:"bytes,17,rep,name=WitnessMapCommunitys,proto3" json:"WitnessMapCommunitys,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CommunityMapLights   map[string]*Addresses   `protobuf:"bytes,18,rep,name=CommunityMapLights,proto3" json:"CommunityMapLights,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TxAveGas             *TxAveGas               `protobuf:"bytes,19,opt,name=TxAveGas,proto3" json:"TxAveGas,omitempty"`
	LastVoteOp           map[string]uint64       `protobuf:"bytes,20,rep,name=LastVoteOp,proto3" json:"LastVoteOp,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DepositWitness       map[string]*DepositInfo `protobuf:"bytes,22,rep,name=DepositWitness,proto3" json:"DepositWitness,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	AddrReward           map[string][]byte       `protobuf:"bytes,23,rep,name=AddrReward,proto3" json:"AddrReward,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// otherDeposit     *sync.Map           //其他押金，key:uint64=交易类型;value:*sync.Map=押金列表;
	OtherDeposit         map[int64][]byte           `protobuf:"bytes,24,rep,name=otherDeposit,proto3" json:"otherDeposit,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DepositFreeGas       map[string]*DepositFreeGas `protobuf:"bytes,25,rep,name=DepositFreeGas,proto3" json:"DepositFreeGas,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *SnapshotBalanceManager) Reset()         { *m = SnapshotBalanceManager{} }
func (m *SnapshotBalanceManager) String() string { return proto.CompactTextString(m) }
func (*SnapshotBalanceManager) ProtoMessage()    {}
func (*SnapshotBalanceManager) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{5}
}
func (m *SnapshotBalanceManager) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotBalanceManager) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotBalanceManager.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotBalanceManager) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotBalanceManager.Merge(m, src)
}
func (m *SnapshotBalanceManager) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotBalanceManager) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotBalanceManager.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotBalanceManager proto.InternalMessageInfo

func (m *SnapshotBalanceManager) GetCountTotal() uint64 {
	if m != nil {
		return m.CountTotal
	}
	return 0
}

func (m *SnapshotBalanceManager) GetNodeWitness() *TxItem {
	if m != nil {
		return m.NodeWitness
	}
	return nil
}

func (m *SnapshotBalanceManager) GetWitnessVote() map[string]uint64 {
	if m != nil {
		return m.WitnessVote
	}
	return nil
}

func (m *SnapshotBalanceManager) GetDepositCommunity() map[string]*DepositInfo {
	if m != nil {
		return m.DepositCommunity
	}
	return nil
}

func (m *SnapshotBalanceManager) GetDepositLight() map[string]*DepositInfo {
	if m != nil {
		return m.DepositLight
	}
	return nil
}

func (m *SnapshotBalanceManager) GetDepositVote() map[string]*DepositInfo {
	if m != nil {
		return m.DepositVote
	}
	return nil
}

func (m *SnapshotBalanceManager) GetCommunityVote() map[string]uint64 {
	if m != nil {
		return m.CommunityVote
	}
	return nil
}

func (m *SnapshotBalanceManager) GetWitnessBackup() *SnapshotWitnessBackup {
	if m != nil {
		return m.WitnessBackup
	}
	return nil
}

func (m *SnapshotBalanceManager) GetAddBlockNum() map[string]uint64 {
	if m != nil {
		return m.AddBlockNum
	}
	return nil
}

func (m *SnapshotBalanceManager) GetAddBlockReward() map[string]uint64 {
	if m != nil {
		return m.AddBlockReward
	}
	return nil
}

func (m *SnapshotBalanceManager) GetBlockIndex() map[string]uint64 {
	if m != nil {
		return m.BlockIndex
	}
	return nil
}

func (m *SnapshotBalanceManager) GetWitnessRatio() map[string]uint64 {
	if m != nil {
		return m.WitnessRatio
	}
	return nil
}

func (m *SnapshotBalanceManager) GetLastDistributeHeight() uint64 {
	if m != nil {
		return m.LastDistributeHeight
	}
	return 0
}

func (m *SnapshotBalanceManager) GetWitnessRewardPool() map[string][]byte {
	if m != nil {
		return m.WitnessRewardPool
	}
	return nil
}

func (m *SnapshotBalanceManager) GetCommunityRewardPool() map[string][]byte {
	if m != nil {
		return m.CommunityRewardPool
	}
	return nil
}

func (m *SnapshotBalanceManager) GetNameNetRewardPool() map[string][]byte {
	if m != nil {
		return m.NameNetRewardPool
	}
	return nil
}

func (m *SnapshotBalanceManager) GetWitnessMapCommunitys() map[string]*Addresses {
	if m != nil {
		return m.WitnessMapCommunitys
	}
	return nil
}

func (m *SnapshotBalanceManager) GetCommunityMapLights() map[string]*Addresses {
	if m != nil {
		return m.CommunityMapLights
	}
	return nil
}

func (m *SnapshotBalanceManager) GetTxAveGas() *TxAveGas {
	if m != nil {
		return m.TxAveGas
	}
	return nil
}

func (m *SnapshotBalanceManager) GetLastVoteOp() map[string]uint64 {
	if m != nil {
		return m.LastVoteOp
	}
	return nil
}

func (m *SnapshotBalanceManager) GetDepositWitness() map[string]*DepositInfo {
	if m != nil {
		return m.DepositWitness
	}
	return nil
}

func (m *SnapshotBalanceManager) GetAddrReward() map[string][]byte {
	if m != nil {
		return m.AddrReward
	}
	return nil
}

func (m *SnapshotBalanceManager) GetOtherDeposit() map[int64][]byte {
	if m != nil {
		return m.OtherDeposit
	}
	return nil
}

func (m *SnapshotBalanceManager) GetDepositFreeGas() map[string]*DepositFreeGas {
	if m != nil {
		return m.DepositFreeGas
	}
	return nil
}

type Addresses struct {
	Addresses            [][]byte `protobuf:"bytes,1,rep,name=Addresses,proto3" json:"Addresses,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Addresses) Reset()         { *m = Addresses{} }
func (m *Addresses) String() string { return proto.CompactTextString(m) }
func (*Addresses) ProtoMessage()    {}
func (*Addresses) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{6}
}
func (m *Addresses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Addresses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Addresses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Addresses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Addresses.Merge(m, src)
}
func (m *Addresses) XXX_Size() int {
	return m.Size()
}
func (m *Addresses) XXX_DiscardUnknown() {
	xxx_messageInfo_Addresses.DiscardUnknown(m)
}

var xxx_messageInfo_Addresses proto.InternalMessageInfo

func (m *Addresses) GetAddresses() [][]byte {
	if m != nil {
		return m.Addresses
	}
	return nil
}

// 交易平均Gas
type TxAveGas struct {
	AllGas               []uint64 `protobuf:"varint,1,rep,packed,name=AllGas,proto3" json:"AllGas,omitempty"`
	Index                uint64   `protobuf:"varint,2,opt,name=Index,proto3" json:"Index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxAveGas) Reset()         { *m = TxAveGas{} }
func (m *TxAveGas) String() string { return proto.CompactTextString(m) }
func (*TxAveGas) ProtoMessage()    {}
func (*TxAveGas) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{7}
}
func (m *TxAveGas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxAveGas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxAveGas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxAveGas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxAveGas.Merge(m, src)
}
func (m *TxAveGas) XXX_Size() int {
	return m.Size()
}
func (m *TxAveGas) XXX_DiscardUnknown() {
	xxx_messageInfo_TxAveGas.DiscardUnknown(m)
}

var xxx_messageInfo_TxAveGas proto.InternalMessageInfo

func (m *TxAveGas) GetAllGas() []uint64 {
	if m != nil {
		return m.AllGas
	}
	return nil
}

func (m *TxAveGas) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

// 质押免gas费地址
type DepositFreeGas struct {
	Owner                []byte   `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	ContractAddresses    []byte   `protobuf:"bytes,2,opt,name=contract_addresses,json=contractAddresses,proto3" json:"contract_addresses,omitempty"`
	Deposit              uint64   `protobuf:"varint,3,opt,name=deposit,proto3" json:"deposit,omitempty"`
	LimitHeight          uint64   `protobuf:"varint,4,opt,name=limit_height,json=limitHeight,proto3" json:"limit_height,omitempty"`
	LimitCount           uint64   `protobuf:"varint,5,opt,name=limit_count,json=limitCount,proto3" json:"limit_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DepositFreeGas) Reset()         { *m = DepositFreeGas{} }
func (m *DepositFreeGas) String() string { return proto.CompactTextString(m) }
func (*DepositFreeGas) ProtoMessage()    {}
func (*DepositFreeGas) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{8}
}
func (m *DepositFreeGas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositFreeGas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositFreeGas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositFreeGas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositFreeGas.Merge(m, src)
}
func (m *DepositFreeGas) XXX_Size() int {
	return m.Size()
}
func (m *DepositFreeGas) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositFreeGas.DiscardUnknown(m)
}

var xxx_messageInfo_DepositFreeGas proto.InternalMessageInfo

func (m *DepositFreeGas) GetOwner() []byte {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *DepositFreeGas) GetContractAddresses() []byte {
	if m != nil {
		return m.ContractAddresses
	}
	return nil
}

func (m *DepositFreeGas) GetDeposit() uint64 {
	if m != nil {
		return m.Deposit
	}
	return 0
}

func (m *DepositFreeGas) GetLimitHeight() uint64 {
	if m != nil {
		return m.LimitHeight
	}
	return 0
}

func (m *DepositFreeGas) GetLimitCount() uint64 {
	if m != nil {
		return m.LimitCount
	}
	return 0
}

type TxItem struct {
	Addr                 []byte   `protobuf:"bytes,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	Value                uint64   `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	VoteType             uint64   `protobuf:"varint,3,opt,name=VoteType,proto3" json:"VoteType,omitempty"`
	LockupHeight         uint64   `protobuf:"varint,4,opt,name=LockupHeight,proto3" json:"LockupHeight,omitempty"`
	Name                 string   `protobuf:"bytes,5,opt,name=Name,proto3" json:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxItem) Reset()         { *m = TxItem{} }
func (m *TxItem) String() string { return proto.CompactTextString(m) }
func (*TxItem) ProtoMessage()    {}
func (*TxItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{9}
}
func (m *TxItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxItem.Merge(m, src)
}
func (m *TxItem) XXX_Size() int {
	return m.Size()
}
func (m *TxItem) XXX_DiscardUnknown() {
	xxx_messageInfo_TxItem.DiscardUnknown(m)
}

var xxx_messageInfo_TxItem proto.InternalMessageInfo

func (m *TxItem) GetAddr() []byte {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *TxItem) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *TxItem) GetVoteType() uint64 {
	if m != nil {
		return m.VoteType
	}
	return 0
}

func (m *TxItem) GetLockupHeight() uint64 {
	if m != nil {
		return m.LockupHeight
	}
	return 0
}

func (m *TxItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type DepositInfo struct {
	WitnessAddr          []byte   `protobuf:"bytes,1,opt,name=WitnessAddr,proto3" json:"WitnessAddr,omitempty"`
	SelfAddr             []byte   `protobuf:"bytes,2,opt,name=SelfAddr,proto3" json:"SelfAddr,omitempty"`
	Value                uint64   `protobuf:"varint,3,opt,name=Value,proto3" json:"Value,omitempty"`
	Name                 string   `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	Height               uint64   `protobuf:"varint,5,opt,name=Height,proto3" json:"Height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DepositInfo) Reset()         { *m = DepositInfo{} }
func (m *DepositInfo) String() string { return proto.CompactTextString(m) }
func (*DepositInfo) ProtoMessage()    {}
func (*DepositInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{10}
}
func (m *DepositInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositInfo.Merge(m, src)
}
func (m *DepositInfo) XXX_Size() int {
	return m.Size()
}
func (m *DepositInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DepositInfo proto.InternalMessageInfo

func (m *DepositInfo) GetWitnessAddr() []byte {
	if m != nil {
		return m.WitnessAddr
	}
	return nil
}

func (m *DepositInfo) GetSelfAddr() []byte {
	if m != nil {
		return m.SelfAddr
	}
	return nil
}

func (m *DepositInfo) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *DepositInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DepositInfo) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type SnapshotWitnessChain struct {
	// 未分配见证人
	WitnessNotGroup []*SnapshotWitness `protobuf:"bytes,1,rep,name=WitnessNotGroup,proto3" json:"WitnessNotGroup,omitempty"`
	// 所有未分配见证人
	AllWitnessNotGroup map[string]*SnapshotWitness `protobuf:"bytes,2,rep,name=AllWitnessNotGroup,proto3" json:"AllWitnessNotGroup,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 未分配见证人大组
	BigGroupNotGroup       *SnapshotWitnessBigGroup     `protobuf:"bytes,3,opt,name=BigGroupNotGroup,proto3" json:"BigGroupNotGroup,omitempty"`
	BigGroup               []*SnapshotWitnessBigGroup   `protobuf:"bytes,4,rep,name=BigGroup,proto3" json:"BigGroup,omitempty"`
	SmallGroup             []*SnapshotWitnessSmallGroup `protobuf:"bytes,5,rep,name=SmallGroup,proto3" json:"SmallGroup,omitempty"`
	Group                  []*SnapshotGroup             `protobuf:"bytes,6,rep,name=Group,proto3" json:"Group,omitempty"`
	Witness                []*SnapshotWitness           `protobuf:"bytes,7,rep,name=Witness,proto3" json:"Witness,omitempty"`
	Block                  []*SnapshotBlock             `protobuf:"bytes,8,rep,name=Block,proto3" json:"Block,omitempty"`
	CurrentSmallGroupIndex int32                        `protobuf:"varint,9,opt,name=CurrentSmallGroupIndex,proto3" json:"CurrentSmallGroupIndex,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                     `json:"-"`
	XXX_unrecognized       []byte                       `json:"-"`
	XXX_sizecache          int32                        `json:"-"`
}

func (m *SnapshotWitnessChain) Reset()         { *m = SnapshotWitnessChain{} }
func (m *SnapshotWitnessChain) String() string { return proto.CompactTextString(m) }
func (*SnapshotWitnessChain) ProtoMessage()    {}
func (*SnapshotWitnessChain) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{11}
}
func (m *SnapshotWitnessChain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotWitnessChain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotWitnessChain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotWitnessChain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotWitnessChain.Merge(m, src)
}
func (m *SnapshotWitnessChain) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotWitnessChain) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotWitnessChain.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotWitnessChain proto.InternalMessageInfo

func (m *SnapshotWitnessChain) GetWitnessNotGroup() []*SnapshotWitness {
	if m != nil {
		return m.WitnessNotGroup
	}
	return nil
}

func (m *SnapshotWitnessChain) GetAllWitnessNotGroup() map[string]*SnapshotWitness {
	if m != nil {
		return m.AllWitnessNotGroup
	}
	return nil
}

func (m *SnapshotWitnessChain) GetBigGroupNotGroup() *SnapshotWitnessBigGroup {
	if m != nil {
		return m.BigGroupNotGroup
	}
	return nil
}

func (m *SnapshotWitnessChain) GetBigGroup() []*SnapshotWitnessBigGroup {
	if m != nil {
		return m.BigGroup
	}
	return nil
}

func (m *SnapshotWitnessChain) GetSmallGroup() []*SnapshotWitnessSmallGroup {
	if m != nil {
		return m.SmallGroup
	}
	return nil
}

func (m *SnapshotWitnessChain) GetGroup() []*SnapshotGroup {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *SnapshotWitnessChain) GetWitness() []*SnapshotWitness {
	if m != nil {
		return m.Witness
	}
	return nil
}

func (m *SnapshotWitnessChain) GetBlock() []*SnapshotBlock {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *SnapshotWitnessChain) GetCurrentSmallGroupIndex() int32 {
	if m != nil {
		return m.CurrentSmallGroupIndex
	}
	return 0
}

// 大组
type SnapshotWitnessBigGroup struct {
	// uint64 Key =1;// 唯一键, 块高度
	Witnesses            []*SnapshotWitness `protobuf:"bytes,1,rep,name=Witnesses,proto3" json:"Witnesses,omitempty"`
	WitnessBackup        []*SnapshotWitness `protobuf:"bytes,2,rep,name=WitnessBackup,proto3" json:"WitnessBackup,omitempty"`
	Keys                 []string           `protobuf:"bytes,3,rep,name=Keys,proto3" json:"Keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SnapshotWitnessBigGroup) Reset()         { *m = SnapshotWitnessBigGroup{} }
func (m *SnapshotWitnessBigGroup) String() string { return proto.CompactTextString(m) }
func (*SnapshotWitnessBigGroup) ProtoMessage()    {}
func (*SnapshotWitnessBigGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{12}
}
func (m *SnapshotWitnessBigGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotWitnessBigGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotWitnessBigGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotWitnessBigGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotWitnessBigGroup.Merge(m, src)
}
func (m *SnapshotWitnessBigGroup) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotWitnessBigGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotWitnessBigGroup.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotWitnessBigGroup proto.InternalMessageInfo

func (m *SnapshotWitnessBigGroup) GetWitnesses() []*SnapshotWitness {
	if m != nil {
		return m.Witnesses
	}
	return nil
}

func (m *SnapshotWitnessBigGroup) GetWitnessBackup() []*SnapshotWitness {
	if m != nil {
		return m.WitnessBackup
	}
	return nil
}

func (m *SnapshotWitnessBigGroup) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

// 小组
// =WitnessSmallGroup
type SnapshotWitnessSmallGroup struct {
	// uint64 Key =1;// 唯一键, 块高度
	Task bool `protobuf:"varint,1,opt,name=Task,proto3" json:"Task,omitempty"`
	// PreGroup     *SnapshotWitnessSmallGroup //上一个组
	// NextGroup    *SnapshotWitnessSmallGroup //下一个组
	Height               uint64             `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
	Witness              []*SnapshotWitness `protobuf:"bytes,3,rep,name=Witness,proto3" json:"Witness,omitempty"`
	BlockGroup           *SnapshotGroup     `protobuf:"bytes,4,opt,name=BlockGroup,proto3" json:"BlockGroup,omitempty"`
	IsBuildGroup         bool               `protobuf:"varint,5,opt,name=IsBuildGroup,proto3" json:"IsBuildGroup,omitempty"`
	Tag                  bool               `protobuf:"varint,6,opt,name=Tag,proto3" json:"Tag,omitempty"`
	IsCount              bool               `protobuf:"varint,7,opt,name=IsCount,proto3" json:"IsCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SnapshotWitnessSmallGroup) Reset()         { *m = SnapshotWitnessSmallGroup{} }
func (m *SnapshotWitnessSmallGroup) String() string { return proto.CompactTextString(m) }
func (*SnapshotWitnessSmallGroup) ProtoMessage()    {}
func (*SnapshotWitnessSmallGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{13}
}
func (m *SnapshotWitnessSmallGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotWitnessSmallGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotWitnessSmallGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotWitnessSmallGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotWitnessSmallGroup.Merge(m, src)
}
func (m *SnapshotWitnessSmallGroup) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotWitnessSmallGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotWitnessSmallGroup.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotWitnessSmallGroup proto.InternalMessageInfo

func (m *SnapshotWitnessSmallGroup) GetTask() bool {
	if m != nil {
		return m.Task
	}
	return false
}

func (m *SnapshotWitnessSmallGroup) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *SnapshotWitnessSmallGroup) GetWitness() []*SnapshotWitness {
	if m != nil {
		return m.Witness
	}
	return nil
}

func (m *SnapshotWitnessSmallGroup) GetBlockGroup() *SnapshotGroup {
	if m != nil {
		return m.BlockGroup
	}
	return nil
}

func (m *SnapshotWitnessSmallGroup) GetIsBuildGroup() bool {
	if m != nil {
		return m.IsBuildGroup
	}
	return false
}

func (m *SnapshotWitnessSmallGroup) GetTag() bool {
	if m != nil {
		return m.Tag
	}
	return false
}

func (m *SnapshotWitnessSmallGroup) GetIsCount() bool {
	if m != nil {
		return m.IsCount
	}
	return false
}

// 组
// =Group
type SnapshotGroup struct {
	// uint64 Key=1;// 唯一键, 块高度
	// PreGroup  *SnapshotGroup   //前置组
	// NextGroup *SnapshotGroup   //下一个组，有分叉，下标为0的是最长链
	Height               uint64           `protobuf:"varint,1,opt,name=Height,proto3" json:"Height,omitempty"`
	Blocks               []*SnapshotBlock `protobuf:"bytes,2,rep,name=Blocks,proto3" json:"Blocks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SnapshotGroup) Reset()         { *m = SnapshotGroup{} }
func (m *SnapshotGroup) String() string { return proto.CompactTextString(m) }
func (*SnapshotGroup) ProtoMessage()    {}
func (*SnapshotGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{14}
}
func (m *SnapshotGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotGroup.Merge(m, src)
}
func (m *SnapshotGroup) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotGroup.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotGroup proto.InternalMessageInfo

func (m *SnapshotGroup) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *SnapshotGroup) GetBlocks() []*SnapshotBlock {
	if m != nil {
		return m.Blocks
	}
	return nil
}

// 见证人
type SnapshotWitness struct {
	Addr             []byte                   `protobuf:"bytes,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	Puk              []byte                   `protobuf:"bytes,2,opt,name=Puk,proto3" json:"Puk,omitempty"`
	Block            *SnapshotBlock           `protobuf:"bytes,3,opt,name=Block,proto3" json:"Block,omitempty"`
	Score            uint64                   `protobuf:"varint,4,opt,name=Score,proto3" json:"Score,omitempty"`
	CommunityVotes   []*VoteScore             `protobuf:"bytes,5,rep,name=CommunityVotes,proto3" json:"CommunityVotes,omitempty"`
	Votes            []*VoteScore             `protobuf:"bytes,6,rep,name=Votes,proto3" json:"Votes,omitempty"`
	VoteNum          uint64                   `protobuf:"varint,7,opt,name=VoteNum,proto3" json:"VoteNum,omitempty"`
	BlockHeight      uint64                   `protobuf:"varint,8,opt,name=BlockHeight,proto3" json:"BlockHeight,omitempty"`
	CreateBlockTime  int64                    `protobuf:"varint,9,opt,name=CreateBlockTime,proto3" json:"CreateBlockTime,omitempty"`
	WitnessBigGroup  *SnapshotWitnessBigGroup `protobuf:"bytes,10,opt,name=WitnessBigGroup,proto3" json:"WitnessBigGroup,omitempty"`
	CheckIsMining    bool                     `protobuf:"varint,11,opt,name=CheckIsMining,proto3" json:"CheckIsMining,omitempty"`
	SignExist        bool                     `protobuf:"varint,12,opt,name=SignExist,proto3" json:"SignExist,omitempty"`
	CreateTime       int64                    `protobuf:"varint,13,opt,name=CreateTime,proto3" json:"CreateTime,omitempty"`
	SleepTime        int64                    `protobuf:"varint,14,opt,name=SleepTime,proto3" json:"SleepTime,omitempty"`
	SmallGroupHeight uint64                   `protobuf:"varint,15,opt,name=SmallGroupHeight,proto3" json:"SmallGroupHeight,omitempty"`
	// 临时存见证人指针地址,恢复未分配的见证人可能会使用到
	PtrAddr              string   `protobuf:"bytes,16,opt,name=PtrAddr,proto3" json:"PtrAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotWitness) Reset()         { *m = SnapshotWitness{} }
func (m *SnapshotWitness) String() string { return proto.CompactTextString(m) }
func (*SnapshotWitness) ProtoMessage()    {}
func (*SnapshotWitness) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{15}
}
func (m *SnapshotWitness) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotWitness) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotWitness.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotWitness) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotWitness.Merge(m, src)
}
func (m *SnapshotWitness) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotWitness) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotWitness.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotWitness proto.InternalMessageInfo

func (m *SnapshotWitness) GetAddr() []byte {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *SnapshotWitness) GetPuk() []byte {
	if m != nil {
		return m.Puk
	}
	return nil
}

func (m *SnapshotWitness) GetBlock() *SnapshotBlock {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *SnapshotWitness) GetScore() uint64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *SnapshotWitness) GetCommunityVotes() []*VoteScore {
	if m != nil {
		return m.CommunityVotes
	}
	return nil
}

func (m *SnapshotWitness) GetVotes() []*VoteScore {
	if m != nil {
		return m.Votes
	}
	return nil
}

func (m *SnapshotWitness) GetVoteNum() uint64 {
	if m != nil {
		return m.VoteNum
	}
	return 0
}

func (m *SnapshotWitness) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *SnapshotWitness) GetCreateBlockTime() int64 {
	if m != nil {
		return m.CreateBlockTime
	}
	return 0
}

func (m *SnapshotWitness) GetWitnessBigGroup() *SnapshotWitnessBigGroup {
	if m != nil {
		return m.WitnessBigGroup
	}
	return nil
}

func (m *SnapshotWitness) GetCheckIsMining() bool {
	if m != nil {
		return m.CheckIsMining
	}
	return false
}

func (m *SnapshotWitness) GetSignExist() bool {
	if m != nil {
		return m.SignExist
	}
	return false
}

func (m *SnapshotWitness) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *SnapshotWitness) GetSleepTime() int64 {
	if m != nil {
		return m.SleepTime
	}
	return 0
}

func (m *SnapshotWitness) GetSmallGroupHeight() uint64 {
	if m != nil {
		return m.SmallGroupHeight
	}
	return 0
}

func (m *SnapshotWitness) GetPtrAddr() string {
	if m != nil {
		return m.PtrAddr
	}
	return ""
}

// 块
// =Block
type SnapshotBlock struct {
	Id         []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	PreBlockID []byte `protobuf:"bytes,2,opt,name=PreBlockID,proto3" json:"PreBlockID,omitempty"`
	// PreBlock   *SnapshotBlock   //前置区块高度
	// NextBlock  *SnapshotBlock   //下一个区块高度
	// Group   *SnapshotGroup   //所属组
	Height uint64 `protobuf:"varint,3,opt,name=Height,proto3" json:"Height,omitempty"`
	// Witness *SnapshotWitness //是哪个见证人出的块
	IsCount              bool     `protobuf:"varint,4,opt,name=IsCount,proto3" json:"IsCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotBlock) Reset()         { *m = SnapshotBlock{} }
func (m *SnapshotBlock) String() string { return proto.CompactTextString(m) }
func (*SnapshotBlock) ProtoMessage()    {}
func (*SnapshotBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_50abed1b2a365d8a, []int{16}
}
func (m *SnapshotBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotBlock.Merge(m, src)
}
func (m *SnapshotBlock) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotBlock.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotBlock proto.InternalMessageInfo

func (m *SnapshotBlock) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SnapshotBlock) GetPreBlockID() []byte {
	if m != nil {
		return m.PreBlockID
	}
	return nil
}

func (m *SnapshotBlock) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *SnapshotBlock) GetIsCount() bool {
	if m != nil {
		return m.IsCount
	}
	return false
}

func init() {
	proto.RegisterType((*SnapshotChain)(nil), "go_protos.SnapshotChain")
	proto.RegisterType((*SnapshotWitnessBackup)(nil), "go_protos.SnapshotWitnessBackup")
	proto.RegisterMapType((map[string]uint64)(nil), "go_protos.SnapshotWitnessBackup.BlacklistEntry")
	proto.RegisterMapType((map[string]*VoteScore)(nil), "go_protos.SnapshotWitnessBackup.LightNodeEntry")
	proto.RegisterMapType((map[string]*VoteScoreArr)(nil), "go_protos.SnapshotWitnessBackup.VoteCommunityEntry")
	proto.RegisterMapType((map[string]*VoteScore)(nil), "go_protos.SnapshotWitnessBackup.VoteCommunityListEntry")
	proto.RegisterMapType((map[string]*VoteScoreArr)(nil), "go_protos.SnapshotWitnessBackup.VoteEntry")
	proto.RegisterMapType((map[string]*VoteScore)(nil), "go_protos.SnapshotWitnessBackup.VoteListEntry")
	proto.RegisterMapType((map[string]*BackupWitness)(nil), "go_protos.SnapshotWitnessBackup.WitnessesMapEntry")
	proto.RegisterType((*BackupWitness)(nil), "go_protos.BackupWitness")
	proto.RegisterType((*VoteScoreArr)(nil), "go_protos.VoteScoreArr")
	proto.RegisterType((*VoteScore)(nil), "go_protos.VoteScore")
	proto.RegisterType((*SnapshotBalanceManager)(nil), "go_protos.SnapshotBalanceManager")
	proto.RegisterMapType((map[string]uint64)(nil), "go_protos.SnapshotBalanceManager.AddBlockNumEntry")
	proto.RegisterMapType((map[string]uint64)(nil), "go_protos.SnapshotBalanceManager.AddBlockRewardEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "go_protos.SnapshotBalanceManager.AddrRewardEntry")
	proto.RegisterMapType((map[string]uint64)(nil), "go_protos.SnapshotBalanceManager.BlockIndexEntry")
	proto.RegisterMapType((map[string]*Addresses)(nil), "go_protos.SnapshotBalanceManager.CommunityMapLightsEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "go_protos.SnapshotBalanceManager.CommunityRewardPoolEntry")
	proto.RegisterMapType((map[string]uint64)(nil), "go_protos.SnapshotBalanceManager.CommunityVoteEntry")
	proto.RegisterMapType((map[string]*DepositInfo)(nil), "go_protos.SnapshotBalanceManager.DepositCommunityEntry")
	proto.RegisterMapType((map[string]*DepositFreeGas)(nil), "go_protos.SnapshotBalanceManager.DepositFreeGasEntry")
	proto.RegisterMapType((map[string]*DepositInfo)(nil), "go_protos.SnapshotBalanceManager.DepositLightEntry")
	proto.RegisterMapType((map[string]*DepositInfo)(nil), "go_protos.SnapshotBalanceManager.DepositVoteEntry")
	proto.RegisterMapType((map[string]*DepositInfo)(nil), "go_protos.SnapshotBalanceManager.DepositWitnessEntry")
	proto.RegisterMapType((map[string]uint64)(nil), "go_protos.SnapshotBalanceManager.LastVoteOpEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "go_protos.SnapshotBalanceManager.NameNetRewardPoolEntry")
	proto.RegisterMapType((map[int64][]byte)(nil), "go_protos.SnapshotBalanceManager.OtherDepositEntry")
	proto.RegisterMapType((map[string]*Addresses)(nil), "go_protos.SnapshotBalanceManager.WitnessMapCommunitysEntry")
	proto.RegisterMapType((map[string]uint64)(nil), "go_protos.SnapshotBalanceManager.WitnessRatioEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "go_protos.SnapshotBalanceManager.WitnessRewardPoolEntry")
	proto.RegisterMapType((map[string]uint64)(nil), "go_protos.SnapshotBalanceManager.WitnessVoteEntry")
	proto.RegisterType((*Addresses)(nil), "go_protos.Addresses")
	proto.RegisterType((*TxAveGas)(nil), "go_protos.TxAveGas")
	proto.RegisterType((*DepositFreeGas)(nil), "go_protos.DepositFreeGas")
	proto.RegisterType((*TxItem)(nil), "go_protos.TxItem")
	proto.RegisterType((*DepositInfo)(nil), "go_protos.DepositInfo")
	proto.RegisterType((*SnapshotWitnessChain)(nil), "go_protos.SnapshotWitnessChain")
	proto.RegisterMapType((map[string]*SnapshotWitness)(nil), "go_protos.SnapshotWitnessChain.AllWitnessNotGroupEntry")
	proto.RegisterType((*SnapshotWitnessBigGroup)(nil), "go_protos.SnapshotWitnessBigGroup")
	proto.RegisterType((*SnapshotWitnessSmallGroup)(nil), "go_protos.SnapshotWitnessSmallGroup")
	proto.RegisterType((*SnapshotGroup)(nil), "go_protos.SnapshotGroup")
	proto.RegisterType((*SnapshotWitness)(nil), "go_protos.SnapshotWitness")
	proto.RegisterType((*SnapshotBlock)(nil), "go_protos.SnapshotBlock")
}

func init() { proto.RegisterFile("snapshotchain.proto", fileDescriptor_50abed1b2a365d8a) }

var fileDescriptor_50abed1b2a365d8a = []byte{
	// 2102 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0xcd, 0x72, 0xe3, 0xc6,
	0xf1, 0xff, 0x83, 0xa4, 0x24, 0xb2, 0xf9, 0xa9, 0x91, 0x2c, 0x61, 0xf5, 0x4f, 0x64, 0x1a, 0xb5,
	0x95, 0x62, 0xb6, 0x62, 0xae, 0xb3, 0xeb, 0x38, 0x8a, 0xed, 0x5d, 0x5b, 0x1f, 0x5e, 0x8b, 0x89,
	0x24, 0xcb, 0x10, 0x6b, 0xb7, 0xb4, 0x89, 0x6b, 0x0b, 0x26, 0x67, 0x49, 0x94, 0x20, 0x80, 0x01,
	0x40, 0x7b, 0xf5, 0x02, 0xc9, 0x29, 0xf7, 0xdc, 0x72, 0xce, 0xd9, 0x2f, 0x91, 0x43, 0x0e, 0x79,
	0x80, 0x1c, 0x52, 0xeb, 0x17, 0x49, 0x4d, 0xcf, 0x00, 0x98, 0x01, 0x41, 0x11, 0x4c, 0xe9, 0xc4,
	0x99, 0x66, 0xff, 0x7e, 0xd3, 0xd3, 0xd3, 0xd3, 0x3d, 0x33, 0x80, 0x8d, 0xc0, 0xb5, 0x26, 0xc1,
	0xd8, 0x0b, 0x07, 0x63, 0xcb, 0x76, 0xbb, 0x13, 0xdf, 0x0b, 0x3d, 0x52, 0x19, 0x79, 0xaf, 0xb0,
	0x15, 0x18, 0x7f, 0x2b, 0x41, 0xfd, 0x42, 0xa8, 0x1c, 0x32, 0x15, 0xd2, 0x80, 0xc2, 0x99, 0xa7,
	0x6b, 0x6d, 0xad, 0x53, 0x32, 0x0b, 0x67, 0x1e, 0xb9, 0x0f, 0xf5, 0x8b, 0xd0, 0xf2, 0x43, 0xdb,
	0x1d, 0x1d, 0x38, 0xde, 0xe0, 0x4a, 0x2f, 0xe0, 0x5f, 0xaa, 0x90, 0xfc, 0x0c, 0x1a, 0x28, 0xc0,
	0x5e, 0xdf, 0xbe, 0xa6, 0x7a, 0x11, 0xd5, 0x52, 0x52, 0x62, 0x40, 0xed, 0x70, 0xea, 0xfb, 0xd4,
	0xe5, 0x32, 0xbd, 0x84, 0x5a, 0x8a, 0x8c, 0xe9, 0x9c, 0x4f, 0x1d, 0x87, 0x0e, 0x2f, 0x42, 0x2b,
	0xa4, 0x81, 0xbe, 0xc2, 0x75, 0x64, 0x19, 0xd3, 0x39, 0xb6, 0x47, 0x63, 0x1a, 0x08, 0x9e, 0x55,
	0xae, 0x23, 0xcb, 0x48, 0x07, 0x9a, 0x17, 0x37, 0xee, 0x00, 0x3b, 0xcf, 0x6c, 0xd7, 0x0e, 0xc6,
	0xfa, 0x5a, 0x5b, 0xeb, 0x94, 0xcd, 0xb4, 0x98, 0x3c, 0x83, 0xfa, 0x0b, 0x3b, 0x74, 0x69, 0x10,
	0x1c, 0x58, 0x83, 0xab, 0xe9, 0x44, 0x2f, 0xb7, 0xb5, 0x4e, 0xf5, 0x51, 0xbb, 0x1b, 0x3b, 0xaa,
	0x1b, 0x39, 0x49, 0xd1, 0x33, 0x55, 0x18, 0x39, 0x84, 0x9a, 0x10, 0xa0, 0x2f, 0xf5, 0x0a, 0xd2,
	0xbc, 0x3b, 0x9f, 0x06, 0xd5, 0x4c, 0x05, 0x44, 0x3e, 0x81, 0xb5, 0x03, 0xcb, 0xb1, 0xdc, 0x01,
	0xd5, 0x01, 0xf1, 0xef, 0x65, 0xe0, 0x85, 0xc6, 0xa9, 0xe5, 0x5a, 0x23, 0xea, 0x9b, 0x11, 0x82,
	0xaf, 0x96, 0x37, 0x89, 0x27, 0xa8, 0x57, 0xdb, 0x5a, 0xa7, 0x6e, 0xaa, 0x42, 0xf2, 0x00, 0x5a,
	0xb2, 0xc7, 0x8f, 0xad, 0x60, 0xac, 0xd7, 0xdb, 0x5a, 0xa7, 0x66, 0xce, 0xc8, 0x8d, 0x7f, 0x57,
	0xe0, 0x9d, 0xcc, 0xc9, 0x93, 0x8f, 0xa0, 0x22, 0x04, 0x34, 0xd0, 0xb5, 0x76, 0xb1, 0x53, 0x7d,
	0xa4, 0x4b, 0xa6, 0x72, 0x2d, 0xa1, 0x61, 0x26, 0xaa, 0xe4, 0x79, 0xec, 0x25, 0x1a, 0x9c, 0x5a,
	0x13, 0xbd, 0x80, 0xd0, 0x47, 0x8b, 0x9c, 0xdd, 0x95, 0x41, 0x5f, 0xb8, 0xa1, 0x7f, 0x63, 0x2a,
	0x3c, 0xe4, 0x12, 0xea, 0xcf, 0xbd, 0x90, 0x1e, 0x7a, 0xd7, 0xd7, 0x53, 0xd7, 0x0e, 0x6f, 0xf4,
	0x22, 0x12, 0x3f, 0x5e, 0x48, 0xac, 0xa0, 0x38, 0xb3, 0xca, 0x44, 0x28, 0xac, 0x2b, 0x82, 0x13,
	0x3b, 0x08, 0xf5, 0x12, 0xd2, 0xff, 0x7a, 0x39, 0x7a, 0x86, 0xe4, 0x43, 0xcc, 0x32, 0x92, 0xa7,
	0x50, 0x62, 0x42, 0x7d, 0x05, 0x99, 0x1f, 0xe4, 0x62, 0xe6, 0x64, 0x88, 0x23, 0xbf, 0x85, 0x32,
	0xfb, 0x45, 0xeb, 0x56, 0x91, 0xa3, 0x9b, 0x8b, 0x23, 0x31, 0x2a, 0xc6, 0x93, 0x53, 0xa8, 0x9c,
	0xd8, 0xa3, 0x71, 0x78, 0xe6, 0x0d, 0xa9, 0xbe, 0x86, 0x64, 0x0f, 0x17, 0x92, 0xc5, 0x08, 0xce,
	0x96, 0x30, 0x30, 0xba, 0x03, 0xc7, 0x1a, 0x5c, 0x39, 0xcc, 0xb6, 0x72, 0x4e, 0xba, 0x18, 0x21,
	0xe8, 0xe2, 0xfe, 0xce, 0x25, 0xac, 0xcf, 0x84, 0x03, 0x69, 0x41, 0xf1, 0x8a, 0xde, 0x60, 0xee,
	0xaa, 0x98, 0xac, 0x49, 0xba, 0xb0, 0xf2, 0x9d, 0xe5, 0x4c, 0x29, 0x26, 0xad, 0xdb, 0xc2, 0x93,
	0xab, 0x7d, 0x5c, 0xd8, 0xd3, 0x76, 0x2e, 0x81, 0xcc, 0x06, 0x44, 0x06, 0xf7, 0xfb, 0x2a, 0xf7,
	0xb6, 0xc4, 0xcd, 0xf0, 0x17, 0x03, 0xcf, 0xa7, 0xfb, 0xbe, 0x2f, 0x53, 0xbf, 0x84, 0xad, 0xec,
	0x60, 0xc8, 0xa0, 0x7f, 0xa0, 0xd2, 0x6f, 0x66, 0xd1, 0xcb, 0xdc, 0xe7, 0x50, 0x89, 0xc3, 0xe1,
	0x6e, 0xac, 0xfd, 0x9a, 0xef, 0xa7, 0xbb, 0x34, 0xd2, 0x84, 0x86, 0x1a, 0x22, 0x77, 0xc0, 0xf9,
	0x29, 0x34, 0xd4, 0x38, 0xc9, 0xe0, 0xdc, 0x94, 0x39, 0x4b, 0x12, 0xda, 0xa0, 0x50, 0x57, 0x22,
	0x81, 0x10, 0x28, 0xed, 0x0f, 0x87, 0x3e, 0xa2, 0x6b, 0x26, 0xb6, 0x19, 0xe1, 0xf9, 0x94, 0x57,
	0xbe, 0x9a, 0xc9, 0x9a, 0x8c, 0x10, 0x0d, 0x11, 0x65, 0x8e, 0x77, 0x88, 0x0e, 0x6b, 0xcc, 0xc4,
	0xb3, 0xe9, 0xb5, 0x28, 0x6c, 0x51, 0xd7, 0x38, 0x86, 0x9a, 0xec, 0x66, 0xb2, 0xa7, 0xf6, 0x45,
	0xfa, 0xcc, 0x9e, 0xab, 0xa2, 0x69, 0x50, 0xbe, 0xce, 0xf1, 0x80, 0xc2, 0x6e, 0x61, 0xef, 0x5a,
	0x7a, 0x1a, 0x05, 0x69, 0x1a, 0x5b, 0xb0, 0x8a, 0xb0, 0x40, 0x58, 0x2d, 0x7a, 0x4c, 0x17, 0xd3,
	0x0e, 0xb7, 0x19, 0xdb, 0xc6, 0x0f, 0xff, 0x0f, 0x5b, 0xd9, 0xc5, 0x86, 0xec, 0x02, 0x1c, 0x7a,
	0x53, 0x37, 0xec, 0x7b, 0xa1, 0xe5, 0x88, 0x93, 0x82, 0x24, 0x21, 0x8f, 0xa1, 0xca, 0xd6, 0x37,
	0x32, 0x8c, 0x2f, 0xe3, 0xba, 0x34, 0xb5, 0xfe, 0x9b, 0x5e, 0x48, 0xaf, 0x4d, 0x59, 0x8b, 0xf4,
	0xa1, 0x2a, 0x9a, 0x68, 0x4a, 0x71, 0x6e, 0x4d, 0x50, 0x8d, 0xe9, 0x4a, 0x20, 0x9e, 0x24, 0x64,
	0x1a, 0x32, 0x80, 0xd6, 0x11, 0x9d, 0x78, 0x81, 0x1d, 0x26, 0x55, 0x61, 0x7e, 0xda, 0x4e, 0x51,
	0xa7, 0x91, 0x9c, 0x7f, 0x86, 0x90, 0xbc, 0x80, 0x9a, 0x90, 0x61, 0x6c, 0x8b, 0xec, 0xfd, 0x38,
	0xf7, 0x00, 0x88, 0x12, 0x05, 0x4d, 0x16, 0x31, 0x9f, 0x88, 0x3e, 0xfa, 0x64, 0x35, 0xaf, 0x4f,
	0x24, 0x90, 0xf0, 0x89, 0x24, 0x21, 0x2f, 0xa1, 0x1e, 0xdb, 0x8e, 0xbc, 0x3c, 0xb9, 0x7f, 0xb8,
	0x98, 0x57, 0x81, 0x89, 0x3a, 0xa9, 0xc8, 0xee, 0xec, 0x20, 0xd5, 0x87, 0xea, 0xfe, 0x70, 0x88,
	0x87, 0x10, 0xb6, 0x99, 0x2a, 0x79, 0x67, 0x2e, 0x81, 0xc4, 0xcc, 0x25, 0x09, 0xf9, 0x06, 0x1a,
	0x51, 0xd7, 0xa4, 0xdf, 0x5b, 0xfe, 0x50, 0x07, 0x24, 0xfe, 0x55, 0x7e, 0x62, 0x8e, 0xe3, 0xdc,
	0x29, 0x32, 0xf2, 0x35, 0x00, 0x76, 0x7b, 0xee, 0x90, 0xbe, 0xd1, 0xab, 0x48, 0xfd, 0xcb, 0xc5,
	0xd4, 0x09, 0x86, 0xd3, 0x4a, 0x24, 0x2c, 0xb4, 0xa2, 0x0a, 0x65, 0x85, 0xb6, 0xa7, 0xd7, 0xf2,
	0x86, 0x96, 0x8c, 0x52, 0xcf, 0x4a, 0x28, 0x22, 0x8f, 0x60, 0xf3, 0xc4, 0x0a, 0xc2, 0x23, 0x3b,
	0x08, 0x7d, 0xfb, 0xdb, 0x69, 0x48, 0x8f, 0x29, 0xc6, 0x6e, 0x1d, 0x77, 0x73, 0xe6, 0x7f, 0xe4,
	0x75, 0x5c, 0x73, 0xf9, 0x84, 0xcf, 0x3d, 0xcf, 0xd1, 0x1b, 0x68, 0xd1, 0x5e, 0x7e, 0x8b, 0x62,
	0xa8, 0x38, 0x05, 0xcd, 0xc8, 0x89, 0x03, 0x1b, 0x71, 0x54, 0x49, 0x23, 0x35, 0x71, 0xa4, 0x8f,
	0x97, 0x08, 0xd3, 0xf4, 0x58, 0x59, 0xb4, 0x6c, 0x56, 0x67, 0xd6, 0x35, 0x3d, 0xa3, 0xa1, 0x34,
	0x56, 0x2b, 0xef, 0xac, 0x66, 0xa0, 0x62, 0x56, 0x33, 0x72, 0xe2, 0xc1, 0xa6, 0x98, 0xea, 0xa9,
	0x35, 0x89, 0x0d, 0x09, 0xf4, 0x75, 0x1c, 0xea, 0x93, 0xdc, 0x0e, 0x54, 0xd0, 0x7c, 0xb4, 0x4c,
	0x62, 0x62, 0x03, 0x89, 0x7b, 0xa7, 0xd6, 0x04, 0x53, 0x4a, 0xa0, 0x13, 0x1c, 0xee, 0x37, 0x4b,
	0x78, 0x31, 0xc6, 0xf2, 0xc1, 0x32, 0x48, 0xc9, 0x43, 0x28, 0xf7, 0xdf, 0xec, 0x7f, 0x47, 0xbf,
	0xb4, 0x02, 0x7d, 0x03, 0x77, 0xfc, 0x86, 0x92, 0xee, 0xf9, 0x5f, 0x66, 0xac, 0xc4, 0xb6, 0x0a,
	0x0b, 0x31, 0x96, 0x33, 0xbe, 0x9a, 0xe8, 0x9b, 0x79, 0xb7, 0x4a, 0x82, 0x11, 0x5b, 0x25, 0x11,
	0xb0, 0xcd, 0x2d, 0xb2, 0x5c, 0x54, 0x78, 0xb6, 0xf2, 0x6e, 0x6e, 0x15, 0x27, 0x36, 0xb7, 0x2a,
	0x64, 0x16, 0xb3, 0x1a, 0x2a, 0xf2, 0xc6, 0x76, 0x5e, 0x8b, 0x13, 0x8c, 0xb0, 0x38, 0x11, 0xb0,
	0xcd, 0xed, 0x85, 0x63, 0xea, 0x8b, 0x91, 0x74, 0x3d, 0xef, 0xe6, 0xfe, 0x4a, 0x42, 0x89, 0xcd,
	0x2d, 0x13, 0x49, 0xae, 0x78, 0xe6, 0x53, 0x5c, 0x94, 0x7b, 0x4b, 0xba, 0x42, 0xe0, 0x54, 0x57,
	0x08, 0xe1, 0xce, 0x53, 0x68, 0xa5, 0xab, 0xee, 0x32, 0x47, 0xae, 0x9d, 0xdf, 0xc3, 0x3b, 0x99,
	0xa5, 0x35, 0x83, 0xe4, 0x17, 0xea, 0x59, 0x70, 0x4b, 0x9a, 0x80, 0xa0, 0xe8, 0xb9, 0xaf, 0x3d,
	0x99, 0xfc, 0x05, 0xac, 0xcf, 0x94, 0xd5, 0x3b, 0x21, 0x7e, 0x1e, 0x1f, 0x25, 0x6e, 0x9b, 0xf5,
	0xf2, 0xbc, 0x9f, 0x4b, 0xdb, 0xf4, 0x7f, 0xf3, 0xe7, 0x53, 0x68, 0xa5, 0xeb, 0xde, 0x52, 0xf8,
	0x7d, 0xd8, 0xc8, 0x28, 0x6f, 0x4b, 0x51, 0x3c, 0x81, 0x66, 0xaa, 0x8c, 0x2d, 0x05, 0xff, 0x2c,
	0xa9, 0x2c, 0x71, 0xc1, 0x5a, 0x8a, 0xe0, 0x08, 0xb6, 0xb2, 0xeb, 0xcb, 0x22, 0x96, 0x9a, 0xcc,
	0xf2, 0x0c, 0xf4, 0x79, 0xb5, 0x63, 0x29, 0x9e, 0x23, 0xd8, 0xca, 0xae, 0x0b, 0x4b, 0xb1, 0x7c,
	0x03, 0xf7, 0xe6, 0xa6, 0xfc, 0xe5, 0xae, 0x4d, 0x2c, 0xe7, 0xe0, 0x4d, 0x59, 0xdd, 0x85, 0xdb,
	0x73, 0x52, 0xfc, 0x1d, 0x90, 0x3f, 0x81, 0x66, 0x2a, 0x57, 0x2f, 0xb5, 0x9c, 0x97, 0xb0, 0x91,
	0x91, 0x93, 0xef, 0x64, 0xbb, 0x3d, 0x81, 0x66, 0x2a, 0x27, 0x2f, 0xb5, 0x28, 0x9f, 0xc1, 0xfa,
	0x4c, 0xf6, 0x95, 0x09, 0x8a, 0x8b, 0x08, 0xfe, 0x10, 0x4f, 0x4d, 0xce, 0xb1, 0x19, 0x36, 0x3c,
	0x54, 0xa7, 0x76, 0x6f, 0x76, 0x6a, 0x82, 0x40, 0xbe, 0xcd, 0xfe, 0x1c, 0x2a, 0xf1, 0x7a, 0x90,
	0x9f, 0x48, 0x1d, 0xbc, 0x60, 0xd6, 0xcc, 0x44, 0x60, 0xec, 0x25, 0x35, 0x9b, 0x5d, 0x0c, 0xf7,
	0x1d, 0x87, 0x15, 0x0a, 0xa6, 0x56, 0x32, 0x45, 0x8f, 0x4d, 0x83, 0x1f, 0x66, 0xc5, 0x0a, 0x61,
	0xc7, 0xf8, 0x41, 0x4b, 0xd7, 0x17, 0xa6, 0xe8, 0x7d, 0xef, 0xd2, 0xe8, 0xd6, 0xcc, 0x3b, 0xe4,
	0x7d, 0x20, 0x03, 0xcf, 0x0d, 0x7d, 0x6b, 0x10, 0xbe, 0xb2, 0x62, 0x4b, 0xb8, 0x4b, 0xd6, 0xa3,
	0x7f, 0x12, 0x7b, 0x75, 0x58, 0x1b, 0x8a, 0x52, 0xc8, 0xef, 0xa7, 0x51, 0x97, 0xbc, 0x07, 0x35,
	0xc7, 0xbe, 0xb6, 0xc3, 0x57, 0x63, 0x7e, 0x4a, 0xe5, 0x17, 0xd5, 0x2a, 0xca, 0xc4, 0xe1, 0xf4,
	0x5d, 0xe0, 0xdd, 0x57, 0x03, 0x76, 0x11, 0x15, 0x6f, 0xc6, 0x80, 0x22, 0xbc, 0x9a, 0x1a, 0x7f,
	0xd2, 0x60, 0x95, 0x5f, 0x3c, 0x33, 0xaf, 0xf8, 0x9b, 0xb0, 0xf2, 0x5c, 0x0e, 0x46, 0xec, 0x90,
	0x1d, 0xfe, 0xa0, 0xd6, 0xbf, 0x99, 0x44, 0x37, 0xfd, 0xb8, 0x4f, 0x0c, 0xa8, 0x9d, 0x78, 0xec,
	0xb6, 0x72, 0x2c, 0x1b, 0xa5, 0xc8, 0xd8, 0x48, 0x2c, 0x13, 0xa0, 0x39, 0x15, 0x13, 0xdb, 0xc6,
	0x5f, 0xb4, 0xf8, 0x5a, 0xc7, 0x82, 0x93, 0xb4, 0xe3, 0x9b, 0xaf, 0x64, 0x94, 0x2c, 0x62, 0x56,
	0x5c, 0x50, 0xe7, 0xb5, 0x74, 0x9f, 0x8f, 0xfb, 0x89, 0xdd, 0x45, 0xd9, 0xee, 0x68, 0xdc, 0x52,
	0x32, 0x2e, 0x5b, 0x64, 0x61, 0x29, 0x77, 0x8e, 0xe8, 0x19, 0xff, 0x5c, 0x81, 0xcd, 0xac, 0x67,
	0x69, 0x72, 0x04, 0x4d, 0xd1, 0x3f, 0xf3, 0xc2, 0x2f, 0x7d, 0x6f, 0x3a, 0x11, 0xcf, 0x14, 0x3b,
	0xf3, 0xaf, 0x73, 0x66, 0x1a, 0x42, 0x46, 0x40, 0xf6, 0x1d, 0x27, 0x4d, 0x54, 0x58, 0xf4, 0x76,
	0x8a, 0x26, 0x74, 0x67, 0x91, 0xe2, 0x10, 0x3a, 0xfb, 0x07, 0x39, 0x83, 0xd6, 0x81, 0x3d, 0xc2,
	0x76, 0x3c, 0x4c, 0x11, 0xf7, 0x8e, 0x71, 0xcb, 0xf5, 0x53, 0x20, 0xcc, 0x19, 0x2c, 0x79, 0x0a,
	0xe5, 0x48, 0x26, 0xde, 0x0c, 0xf2, 0xf0, 0xc4, 0x18, 0x72, 0x04, 0x70, 0x71, 0x6d, 0x39, 0x0e,
	0x67, 0xe0, 0x8f, 0x02, 0xf7, 0xe7, 0x33, 0x24, 0xba, 0xa6, 0x84, 0x23, 0x5d, 0x58, 0xe1, 0x04,
	0xab, 0x33, 0x0f, 0xec, 0x11, 0x01, 0x07, 0x71, 0x35, 0xf2, 0x61, 0xf2, 0x22, 0xb4, 0xb6, 0x70,
	0xb1, 0xe2, 0xd7, 0xa2, 0x2e, 0xac, 0xf0, 0xcf, 0x05, 0xe5, 0xb9, 0xa3, 0xf0, 0xf3, 0x01, 0x57,
	0x23, 0x1f, 0xc1, 0x96, 0xf8, 0x50, 0x90, 0x98, 0xca, 0x33, 0x45, 0xa5, 0xad, 0x75, 0x56, 0xcc,
	0x39, 0xff, 0xee, 0x58, 0xb0, 0x3d, 0x67, 0x49, 0x33, 0x32, 0xe0, 0x07, 0x6a, 0x06, 0xbc, 0x6d,
	0x22, 0x52, 0x0a, 0xfc, 0xbb, 0x06, 0xdb, 0x73, 0x16, 0x87, 0xec, 0xcd, 0x7e, 0xb1, 0xb8, 0x8d,
	0x55, 0xfa, 0x66, 0xf1, 0x79, 0xfa, 0x61, 0xa3, 0xb0, 0x10, 0x9d, 0x7a, 0xd2, 0x20, 0x50, 0xfa,
	0x1d, 0xbd, 0x09, 0xf0, 0x65, 0xab, 0x62, 0x62, 0xdb, 0xf8, 0x73, 0x01, 0xee, 0xcd, 0x0d, 0x03,
	0x86, 0xe8, 0x5b, 0xc1, 0x15, 0xba, 0xa4, 0x6c, 0x62, 0x5b, 0xda, 0xc4, 0x05, 0x79, 0x13, 0xcb,
	0xcb, 0x5e, 0xcc, 0xbf, 0xec, 0x7b, 0xe2, 0xc5, 0x22, 0x0a, 0x72, 0xed, 0xd6, 0x08, 0x93, 0x74,
	0x59, 0xf2, 0xeb, 0x05, 0x07, 0x53, 0xdb, 0x19, 0x46, 0xe1, 0xcd, 0x6c, 0x54, 0x64, 0x6c, 0x45,
	0xfb, 0xd6, 0x08, 0x3f, 0xcd, 0x95, 0x4d, 0xd6, 0x64, 0x19, 0xbe, 0x17, 0x60, 0x3a, 0x16, 0x5f,
	0xe2, 0xa2, 0xae, 0x71, 0x99, 0x7c, 0x86, 0xe4, 0xe0, 0x64, 0xa2, 0x9a, 0x32, 0xd1, 0x0f, 0x60,
	0x15, 0xcd, 0x08, 0xc4, 0x0a, 0xcc, 0x0f, 0x55, 0xa1, 0x67, 0xfc, 0x58, 0x82, 0x66, 0xca, 0x03,
	0x39, 0x1f, 0x79, 0xe3, 0x5d, 0x51, 0x9c, 0xeb, 0x19, 0x65, 0x57, 0xc4, 0x8f, 0xc2, 0x25, 0xf9,
	0x51, 0xf8, 0x53, 0x68, 0x28, 0x07, 0xfc, 0x40, 0xe4, 0x82, 0xec, 0xc7, 0xde, 0x94, 0x2e, 0x3b,
	0x79, 0x71, 0xd0, 0xea, 0x2d, 0x20, 0xae, 0x22, 0x3f, 0x3f, 0xaf, 0x29, 0xcf, 0xcf, 0xac, 0xc6,
	0xf0, 0x2f, 0x7a, 0xdc, 0xa5, 0x65, 0x5e, 0x3f, 0x25, 0x11, 0xe9, 0x40, 0xf3, 0xd0, 0xa7, 0x56,
	0x48, 0x93, 0x2f, 0xb8, 0x15, 0x3c, 0xcf, 0xa4, 0xc5, 0xe4, 0x24, 0x2e, 0x0b, 0x71, 0x7a, 0x84,
	0xdc, 0x69, 0x36, 0x0d, 0x25, 0xf7, 0xa1, 0x7e, 0x38, 0xa6, 0x83, 0xab, 0x5e, 0x70, 0x6a, 0xbb,
	0xb6, 0x3b, 0xc2, 0x0f, 0x96, 0x65, 0x53, 0x15, 0xb2, 0xa3, 0xcc, 0x85, 0x3d, 0x72, 0xbf, 0x78,
	0x63, 0x07, 0xa1, 0x5e, 0x43, 0x8d, 0x44, 0x80, 0x0f, 0xd2, 0x68, 0x24, 0x9a, 0x5d, 0x47, 0xb3,
	0x25, 0x09, 0xa2, 0x1d, 0x4a, 0x27, 0xf8, 0x77, 0x03, 0xff, 0x4e, 0x04, 0xe4, 0x01, 0xb4, 0x92,
	0x4d, 0x27, 0x1c, 0xd4, 0x44, 0x07, 0xcd, 0xc8, 0x99, 0x87, 0xcf, 0x43, 0x1f, 0x43, 0xa7, 0x85,
	0x89, 0x2a, 0xea, 0x1a, 0x7f, 0x4c, 0x02, 0x98, 0x07, 0x43, 0x03, 0x0a, 0xbd, 0xa1, 0x08, 0xb0,
	0x42, 0x6f, 0xc8, 0x8c, 0x3c, 0xf7, 0xb9, 0x1b, 0x7b, 0x47, 0x22, 0xca, 0x24, 0x89, 0x14, 0xf0,
	0x45, 0x25, 0xe0, 0xa5, 0x3d, 0x53, 0x52, 0xf6, 0xcc, 0xc1, 0x4f, 0xff, 0xf1, 0x76, 0x57, 0xfb,
	0xd7, 0xdb, 0x5d, 0xed, 0x3f, 0x6f, 0x77, 0xb5, 0xbf, 0xfe, 0xb8, 0xfb, 0x7f, 0x2f, 0xab, 0xdd,
	0x87, 0xf1, 0x12, 0x7c, 0xbb, 0x8a, 0xbf, 0x8f, 0xff, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x88, 0x1c,
	0xe4, 0xa4, 0x03, 0x20, 0x00, 0x00,
}

func (m *SnapshotChain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotChain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotChain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CurrentBlockHash) > 0 {
		i -= len(m.CurrentBlockHash)
		copy(dAtA[i:], m.CurrentBlockHash)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.CurrentBlockHash)))
		i--
		dAtA[i] = 0x6a
	}
	if m.StopSyncBlock != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.StopSyncBlock))
		i--
		dAtA[i] = 0x58
	}
	if m.Balance != nil {
		{
			size, err := m.Balance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.WitnessChain != nil {
		{
			size, err := m.WitnessChain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.WitnessBackup != nil {
		{
			size, err := m.WitnessBackup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.SyncBlockFinish {
		i--
		if m.SyncBlockFinish {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.HighestBlock != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.HighestBlock))
		i--
		dAtA[i] = 0x30
	}
	if m.PulledStates != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.PulledStates))
		i--
		dAtA[i] = 0x28
	}
	if m.CurrentBlock != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.CurrentBlock))
		i--
		dAtA[i] = 0x20
	}
	if m.StartBlockTime != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.StartBlockTime))
		i--
		dAtA[i] = 0x18
	}
	if m.StartingBlock != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.StartingBlock))
		i--
		dAtA[i] = 0x10
	}
	if m.No != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.No))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotWitnessBackup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotWitnessBackup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotWitnessBackup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Blacklist) > 0 {
		for k := range m.Blacklist {
			v := m.Blacklist[k]
			baseI := i
			i = encodeVarintSnapshotchain(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.LightNode) > 0 {
		for k := range m.LightNode {
			v := m.LightNode[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.VoteList) > 0 {
		for k := range m.VoteList {
			v := m.VoteList[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Vote) > 0 {
		for k := range m.Vote {
			v := m.Vote[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.VoteCommunityList) > 0 {
		for k := range m.VoteCommunityList {
			v := m.VoteCommunityList[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.VoteCommunity) > 0 {
		for k := range m.VoteCommunity {
			v := m.VoteCommunity[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.WitnessesMap) > 0 {
		for k := range m.WitnessesMap {
			v := m.WitnessesMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Witnesses) > 0 {
		for iNdEx := len(m.Witnesses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Witnesses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BackupWitness) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupWitness) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupWitness) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VoteNum != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.VoteNum))
		i--
		dAtA[i] = 0x20
	}
	if m.Score != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Puk) > 0 {
		i -= len(m.Puk)
		copy(dAtA[i:], m.Puk)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Puk)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VoteScoreArr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteScoreArr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteScoreArr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VoteScoreArr) > 0 {
		for iNdEx := len(m.VoteScoreArr) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VoteScoreArr[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VoteScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteScore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteScore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Vote != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.Vote))
		i--
		dAtA[i] = 0x20
	}
	if m.Scores != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.Scores))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Witness) > 0 {
		i -= len(m.Witness)
		copy(dAtA[i:], m.Witness)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Witness)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotBalanceManager) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotBalanceManager) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotBalanceManager) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DepositFreeGas) > 0 {
		for k := range m.DepositFreeGas {
			v := m.DepositFreeGas[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.OtherDeposit) > 0 {
		for k := range m.OtherDeposit {
			v := m.OtherDeposit[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintSnapshotchain(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintSnapshotchain(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.AddrReward) > 0 {
		for k := range m.AddrReward {
			v := m.AddrReward[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintSnapshotchain(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.DepositWitness) > 0 {
		for k := range m.DepositWitness {
			v := m.DepositWitness[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.LastVoteOp) > 0 {
		for k := range m.LastVoteOp {
			v := m.LastVoteOp[k]
			baseI := i
			i = encodeVarintSnapshotchain(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.TxAveGas != nil {
		{
			size, err := m.TxAveGas.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.CommunityMapLights) > 0 {
		for k := range m.CommunityMapLights {
			v := m.CommunityMapLights[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.WitnessMapCommunitys) > 0 {
		for k := range m.WitnessMapCommunitys {
			v := m.WitnessMapCommunitys[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.NameNetRewardPool) > 0 {
		for k := range m.NameNetRewardPool {
			v := m.NameNetRewardPool[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintSnapshotchain(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.CommunityRewardPool) > 0 {
		for k := range m.CommunityRewardPool {
			v := m.CommunityRewardPool[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintSnapshotchain(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.WitnessRewardPool) > 0 {
		for k := range m.WitnessRewardPool {
			v := m.WitnessRewardPool[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintSnapshotchain(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	if m.LastDistributeHeight != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.LastDistributeHeight))
		i--
		dAtA[i] = 0x68
	}
	if len(m.WitnessRatio) > 0 {
		for k := range m.WitnessRatio {
			v := m.WitnessRatio[k]
			baseI := i
			i = encodeVarintSnapshotchain(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.BlockIndex) > 0 {
		for k := range m.BlockIndex {
			v := m.BlockIndex[k]
			baseI := i
			i = encodeVarintSnapshotchain(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.AddBlockReward) > 0 {
		for k := range m.AddBlockReward {
			v := m.AddBlockReward[k]
			baseI := i
			i = encodeVarintSnapshotchain(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.AddBlockNum) > 0 {
		for k := range m.AddBlockNum {
			v := m.AddBlockNum[k]
			baseI := i
			i = encodeVarintSnapshotchain(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.WitnessBackup != nil {
		{
			size, err := m.WitnessBackup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.CommunityVote) > 0 {
		for k := range m.CommunityVote {
			v := m.CommunityVote[k]
			baseI := i
			i = encodeVarintSnapshotchain(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.DepositVote) > 0 {
		for k := range m.DepositVote {
			v := m.DepositVote[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.DepositLight) > 0 {
		for k := range m.DepositLight {
			v := m.DepositLight[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.DepositCommunity) > 0 {
		for k := range m.DepositCommunity {
			v := m.DepositCommunity[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.WitnessVote) > 0 {
		for k := range m.WitnessVote {
			v := m.WitnessVote[k]
			baseI := i
			i = encodeVarintSnapshotchain(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.NodeWitness != nil {
		{
			size, err := m.NodeWitness.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CountTotal != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.CountTotal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Addresses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Addresses) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Addresses) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addresses[iNdEx])
			copy(dAtA[i:], m.Addresses[iNdEx])
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Addresses[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TxAveGas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxAveGas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxAveGas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AllGas) > 0 {
		dAtA21 := make([]byte, len(m.AllGas)*10)
		var j20 int
		for _, num := range m.AllGas {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintSnapshotchain(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DepositFreeGas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositFreeGas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositFreeGas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LimitCount != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.LimitCount))
		i--
		dAtA[i] = 0x28
	}
	if m.LimitHeight != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.LimitHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.Deposit != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.Deposit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ContractAddresses) > 0 {
		i -= len(m.ContractAddresses)
		copy(dAtA[i:], m.ContractAddresses)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.ContractAddresses)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LockupHeight != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.LockupHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.VoteType != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.VoteType))
		i--
		dAtA[i] = 0x18
	}
	if m.Value != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DepositInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Height != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.Value != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SelfAddr) > 0 {
		i -= len(m.SelfAddr)
		copy(dAtA[i:], m.SelfAddr)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.SelfAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WitnessAddr) > 0 {
		i -= len(m.WitnessAddr)
		copy(dAtA[i:], m.WitnessAddr)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.WitnessAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotWitnessChain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotWitnessChain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotWitnessChain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CurrentSmallGroupIndex != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.CurrentSmallGroupIndex))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Block) > 0 {
		for iNdEx := len(m.Block) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Block[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Witness) > 0 {
		for iNdEx := len(m.Witness) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Witness[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Group) > 0 {
		for iNdEx := len(m.Group) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Group[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SmallGroup) > 0 {
		for iNdEx := len(m.SmallGroup) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SmallGroup[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BigGroup) > 0 {
		for iNdEx := len(m.BigGroup) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BigGroup[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.BigGroupNotGroup != nil {
		{
			size, err := m.BigGroupNotGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AllWitnessNotGroup) > 0 {
		for k := range m.AllWitnessNotGroup {
			v := m.AllWitnessNotGroup[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshotchain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.WitnessNotGroup) > 0 {
		for iNdEx := len(m.WitnessNotGroup) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WitnessNotGroup[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotWitnessBigGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotWitnessBigGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotWitnessBigGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.WitnessBackup) > 0 {
		for iNdEx := len(m.WitnessBackup) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WitnessBackup[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Witnesses) > 0 {
		for iNdEx := len(m.Witnesses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Witnesses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotWitnessSmallGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotWitnessSmallGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotWitnessSmallGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsCount {
		i--
		if m.IsCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Tag {
		i--
		if m.Tag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.IsBuildGroup {
		i--
		if m.IsBuildGroup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.BlockGroup != nil {
		{
			size, err := m.BlockGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Witness) > 0 {
		for iNdEx := len(m.Witness) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Witness[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Height != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Task {
		i--
		if m.Task {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Height != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotWitness) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotWitness) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotWitness) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PtrAddr) > 0 {
		i -= len(m.PtrAddr)
		copy(dAtA[i:], m.PtrAddr)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.PtrAddr)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.SmallGroupHeight != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.SmallGroupHeight))
		i--
		dAtA[i] = 0x78
	}
	if m.SleepTime != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.SleepTime))
		i--
		dAtA[i] = 0x70
	}
	if m.CreateTime != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x68
	}
	if m.SignExist {
		i--
		if m.SignExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.CheckIsMining {
		i--
		if m.CheckIsMining {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.WitnessBigGroup != nil {
		{
			size, err := m.WitnessBigGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.CreateBlockTime != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.CreateBlockTime))
		i--
		dAtA[i] = 0x48
	}
	if m.BlockHeight != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x40
	}
	if m.VoteNum != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.VoteNum))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Votes) > 0 {
		for iNdEx := len(m.Votes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Votes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CommunityVotes) > 0 {
		for iNdEx := len(m.CommunityVotes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CommunityVotes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Score != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x20
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshotchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Puk) > 0 {
		i -= len(m.Puk)
		copy(dAtA[i:], m.Puk)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Puk)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsCount {
		i--
		if m.IsCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Height != 0 {
		i = encodeVarintSnapshotchain(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PreBlockID) > 0 {
		i -= len(m.PreBlockID)
		copy(dAtA[i:], m.PreBlockID)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.PreBlockID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSnapshotchain(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSnapshotchain(dAtA []byte, offset int, v uint64) int {
	offset -= sovSnapshotchain(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SnapshotChain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.No != 0 {
		n += 1 + sovSnapshotchain(uint64(m.No))
	}
	if m.StartingBlock != 0 {
		n += 1 + sovSnapshotchain(uint64(m.StartingBlock))
	}
	if m.StartBlockTime != 0 {
		n += 1 + sovSnapshotchain(uint64(m.StartBlockTime))
	}
	if m.CurrentBlock != 0 {
		n += 1 + sovSnapshotchain(uint64(m.CurrentBlock))
	}
	if m.PulledStates != 0 {
		n += 1 + sovSnapshotchain(uint64(m.PulledStates))
	}
	if m.HighestBlock != 0 {
		n += 1 + sovSnapshotchain(uint64(m.HighestBlock))
	}
	if m.SyncBlockFinish {
		n += 2
	}
	if m.WitnessBackup != nil {
		l = m.WitnessBackup.Size()
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.WitnessChain != nil {
		l = m.WitnessChain.Size()
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.Balance != nil {
		l = m.Balance.Size()
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.StopSyncBlock != 0 {
		n += 1 + sovSnapshotchain(uint64(m.StopSyncBlock))
	}
	l = len(m.CurrentBlockHash)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotWitnessBackup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Witnesses) > 0 {
		for _, e := range m.Witnesses {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if len(m.WitnessesMap) > 0 {
		for k, v := range m.WitnessesMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.VoteCommunity) > 0 {
		for k, v := range m.VoteCommunity {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.VoteCommunityList) > 0 {
		for k, v := range m.VoteCommunityList {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.Vote) > 0 {
		for k, v := range m.Vote {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.VoteList) > 0 {
		for k, v := range m.VoteList {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.LightNode) > 0 {
		for k, v := range m.LightNode {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.Blacklist) > 0 {
		for k, v := range m.Blacklist {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + 1 + sovSnapshotchain(uint64(v))
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupWitness) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	l = len(m.Puk)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovSnapshotchain(uint64(m.Score))
	}
	if m.VoteNum != 0 {
		n += 1 + sovSnapshotchain(uint64(m.VoteNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VoteScoreArr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VoteScoreArr) > 0 {
		for _, e := range m.VoteScoreArr {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VoteScore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Witness)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.Scores != 0 {
		n += 1 + sovSnapshotchain(uint64(m.Scores))
	}
	if m.Vote != 0 {
		n += 1 + sovSnapshotchain(uint64(m.Vote))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotBalanceManager) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CountTotal != 0 {
		n += 1 + sovSnapshotchain(uint64(m.CountTotal))
	}
	if m.NodeWitness != nil {
		l = m.NodeWitness.Size()
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if len(m.WitnessVote) > 0 {
		for k, v := range m.WitnessVote {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + 1 + sovSnapshotchain(uint64(v))
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.DepositCommunity) > 0 {
		for k, v := range m.DepositCommunity {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.DepositLight) > 0 {
		for k, v := range m.DepositLight {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.DepositVote) > 0 {
		for k, v := range m.DepositVote {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.CommunityVote) > 0 {
		for k, v := range m.CommunityVote {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + 1 + sovSnapshotchain(uint64(v))
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if m.WitnessBackup != nil {
		l = m.WitnessBackup.Size()
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if len(m.AddBlockNum) > 0 {
		for k, v := range m.AddBlockNum {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + 1 + sovSnapshotchain(uint64(v))
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.AddBlockReward) > 0 {
		for k, v := range m.AddBlockReward {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + 1 + sovSnapshotchain(uint64(v))
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.BlockIndex) > 0 {
		for k, v := range m.BlockIndex {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + 1 + sovSnapshotchain(uint64(v))
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.WitnessRatio) > 0 {
		for k, v := range m.WitnessRatio {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + 1 + sovSnapshotchain(uint64(v))
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if m.LastDistributeHeight != 0 {
		n += 1 + sovSnapshotchain(uint64(m.LastDistributeHeight))
	}
	if len(m.WitnessRewardPool) > 0 {
		for k, v := range m.WitnessRewardPool {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovSnapshotchain(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.CommunityRewardPool) > 0 {
		for k, v := range m.CommunityRewardPool {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovSnapshotchain(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.NameNetRewardPool) > 0 {
		for k, v := range m.NameNetRewardPool {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovSnapshotchain(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.WitnessMapCommunitys) > 0 {
		for k, v := range m.WitnessMapCommunitys {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.CommunityMapLights) > 0 {
		for k, v := range m.CommunityMapLights {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if m.TxAveGas != nil {
		l = m.TxAveGas.Size()
		n += 2 + l + sovSnapshotchain(uint64(l))
	}
	if len(m.LastVoteOp) > 0 {
		for k, v := range m.LastVoteOp {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + 1 + sovSnapshotchain(uint64(v))
			n += mapEntrySize + 2 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.DepositWitness) > 0 {
		for k, v := range m.DepositWitness {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.AddrReward) > 0 {
		for k, v := range m.AddrReward {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovSnapshotchain(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.OtherDeposit) > 0 {
		for k, v := range m.OtherDeposit {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovSnapshotchain(uint64(len(v)))
			}
			mapEntrySize := 1 + sovSnapshotchain(uint64(k)) + l
			n += mapEntrySize + 2 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if len(m.DepositFreeGas) > 0 {
		for k, v := range m.DepositFreeGas {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Addresses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for _, b := range m.Addresses {
			l = len(b)
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxAveGas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllGas) > 0 {
		l = 0
		for _, e := range m.AllGas {
			l += sovSnapshotchain(uint64(e))
		}
		n += 1 + sovSnapshotchain(uint64(l)) + l
	}
	if m.Index != 0 {
		n += 1 + sovSnapshotchain(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DepositFreeGas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	l = len(m.ContractAddresses)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.Deposit != 0 {
		n += 1 + sovSnapshotchain(uint64(m.Deposit))
	}
	if m.LimitHeight != 0 {
		n += 1 + sovSnapshotchain(uint64(m.LimitHeight))
	}
	if m.LimitCount != 0 {
		n += 1 + sovSnapshotchain(uint64(m.LimitCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovSnapshotchain(uint64(m.Value))
	}
	if m.VoteType != 0 {
		n += 1 + sovSnapshotchain(uint64(m.VoteType))
	}
	if m.LockupHeight != 0 {
		n += 1 + sovSnapshotchain(uint64(m.LockupHeight))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DepositInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WitnessAddr)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	l = len(m.SelfAddr)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovSnapshotchain(uint64(m.Value))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovSnapshotchain(uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotWitnessChain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WitnessNotGroup) > 0 {
		for _, e := range m.WitnessNotGroup {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if len(m.AllWitnessNotGroup) > 0 {
		for k, v := range m.AllWitnessNotGroup {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshotchain(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshotchain(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshotchain(uint64(mapEntrySize))
		}
	}
	if m.BigGroupNotGroup != nil {
		l = m.BigGroupNotGroup.Size()
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if len(m.BigGroup) > 0 {
		for _, e := range m.BigGroup {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if len(m.SmallGroup) > 0 {
		for _, e := range m.SmallGroup {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if len(m.Group) > 0 {
		for _, e := range m.Group {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if len(m.Witness) > 0 {
		for _, e := range m.Witness {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if len(m.Block) > 0 {
		for _, e := range m.Block {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if m.CurrentSmallGroupIndex != 0 {
		n += 1 + sovSnapshotchain(uint64(m.CurrentSmallGroupIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotWitnessBigGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Witnesses) > 0 {
		for _, e := range m.Witnesses {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if len(m.WitnessBackup) > 0 {
		for _, e := range m.WitnessBackup {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotWitnessSmallGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Task {
		n += 2
	}
	if m.Height != 0 {
		n += 1 + sovSnapshotchain(uint64(m.Height))
	}
	if len(m.Witness) > 0 {
		for _, e := range m.Witness {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if m.BlockGroup != nil {
		l = m.BlockGroup.Size()
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.IsBuildGroup {
		n += 2
	}
	if m.Tag {
		n += 2
	}
	if m.IsCount {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovSnapshotchain(uint64(m.Height))
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotWitness) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	l = len(m.Puk)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovSnapshotchain(uint64(m.Score))
	}
	if len(m.CommunityVotes) > 0 {
		for _, e := range m.CommunityVotes {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if len(m.Votes) > 0 {
		for _, e := range m.Votes {
			l = e.Size()
			n += 1 + l + sovSnapshotchain(uint64(l))
		}
	}
	if m.VoteNum != 0 {
		n += 1 + sovSnapshotchain(uint64(m.VoteNum))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovSnapshotchain(uint64(m.BlockHeight))
	}
	if m.CreateBlockTime != 0 {
		n += 1 + sovSnapshotchain(uint64(m.CreateBlockTime))
	}
	if m.WitnessBigGroup != nil {
		l = m.WitnessBigGroup.Size()
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.CheckIsMining {
		n += 2
	}
	if m.SignExist {
		n += 2
	}
	if m.CreateTime != 0 {
		n += 1 + sovSnapshotchain(uint64(m.CreateTime))
	}
	if m.SleepTime != 0 {
		n += 1 + sovSnapshotchain(uint64(m.SleepTime))
	}
	if m.SmallGroupHeight != 0 {
		n += 1 + sovSnapshotchain(uint64(m.SmallGroupHeight))
	}
	l = len(m.PtrAddr)
	if l > 0 {
		n += 2 + l + sovSnapshotchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	l = len(m.PreBlockID)
	if l > 0 {
		n += 1 + l + sovSnapshotchain(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovSnapshotchain(uint64(m.Height))
	}
	if m.IsCount {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSnapshotchain(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSnapshotchain(x uint64) (n int) {
	return sovSnapshotchain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SnapshotChain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotChain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotChain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field No", wireType)
			}
			m.No = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.No |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingBlock", wireType)
			}
			m.StartingBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartingBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlockTime", wireType)
			}
			m.StartBlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlockTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBlock", wireType)
			}
			m.CurrentBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PulledStates", wireType)
			}
			m.PulledStates = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PulledStates |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestBlock", wireType)
			}
			m.HighestBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighestBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncBlockFinish", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SyncBlockFinish = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessBackup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WitnessBackup == nil {
				m.WitnessBackup = &SnapshotWitnessBackup{}
			}
			if err := m.WitnessBackup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessChain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WitnessChain == nil {
				m.WitnessChain = &SnapshotWitnessChain{}
			}
			if err := m.WitnessChain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Balance == nil {
				m.Balance = &SnapshotBalanceManager{}
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopSyncBlock", wireType)
			}
			m.StopSyncBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StopSyncBlock |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentBlockHash = append(m.CurrentBlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.CurrentBlockHash == nil {
				m.CurrentBlockHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotWitnessBackup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotWitnessBackup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotWitnessBackup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Witnesses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Witnesses = append(m.Witnesses, &BackupWitness{})
			if err := m.Witnesses[len(m.Witnesses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessesMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WitnessesMap == nil {
				m.WitnessesMap = make(map[string]*BackupWitness)
			}
			var mapkey string
			var mapvalue *BackupWitness
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BackupWitness{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WitnessesMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteCommunity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VoteCommunity == nil {
				m.VoteCommunity = make(map[string]*VoteScoreArr)
			}
			var mapkey string
			var mapvalue *VoteScoreArr
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VoteScoreArr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VoteCommunity[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteCommunityList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VoteCommunityList == nil {
				m.VoteCommunityList = make(map[string]*VoteScore)
			}
			var mapkey string
			var mapvalue *VoteScore
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VoteScore{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VoteCommunityList[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vote == nil {
				m.Vote = make(map[string]*VoteScoreArr)
			}
			var mapkey string
			var mapvalue *VoteScoreArr
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VoteScoreArr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Vote[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VoteList == nil {
				m.VoteList = make(map[string]*VoteScore)
			}
			var mapkey string
			var mapvalue *VoteScore
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VoteScore{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VoteList[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LightNode == nil {
				m.LightNode = make(map[string]*VoteScore)
			}
			var mapkey string
			var mapvalue *VoteScore
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VoteScore{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LightNode[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blacklist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Blacklist == nil {
				m.Blacklist = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Blacklist[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupWitness) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupWitness: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupWitness: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = append(m.Addr[:0], dAtA[iNdEx:postIndex]...)
			if m.Addr == nil {
				m.Addr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Puk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Puk = append(m.Puk[:0], dAtA[iNdEx:postIndex]...)
			if m.Puk == nil {
				m.Puk = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteNum", wireType)
			}
			m.VoteNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoteNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteScoreArr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteScoreArr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteScoreArr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteScoreArr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoteScoreArr = append(m.VoteScoreArr, &VoteScore{})
			if err := m.VoteScoreArr[len(m.VoteScoreArr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Witness", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Witness = append(m.Witness[:0], dAtA[iNdEx:postIndex]...)
			if m.Witness == nil {
				m.Witness = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = append(m.Addr[:0], dAtA[iNdEx:postIndex]...)
			if m.Addr == nil {
				m.Addr = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scores", wireType)
			}
			m.Scores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scores |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			m.Vote = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vote |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotBalanceManager) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotBalanceManager: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotBalanceManager: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountTotal", wireType)
			}
			m.CountTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeWitness", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeWitness == nil {
				m.NodeWitness = &TxItem{}
			}
			if err := m.NodeWitness.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WitnessVote == nil {
				m.WitnessVote = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WitnessVote[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositCommunity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DepositCommunity == nil {
				m.DepositCommunity = make(map[string]*DepositInfo)
			}
			var mapkey string
			var mapvalue *DepositInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DepositInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DepositCommunity[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositLight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DepositLight == nil {
				m.DepositLight = make(map[string]*DepositInfo)
			}
			var mapkey string
			var mapvalue *DepositInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DepositInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DepositLight[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DepositVote == nil {
				m.DepositVote = make(map[string]*DepositInfo)
			}
			var mapkey string
			var mapvalue *DepositInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DepositInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DepositVote[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommunityVote == nil {
				m.CommunityVote = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CommunityVote[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessBackup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WitnessBackup == nil {
				m.WitnessBackup = &SnapshotWitnessBackup{}
			}
			if err := m.WitnessBackup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddBlockNum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddBlockNum == nil {
				m.AddBlockNum = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AddBlockNum[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddBlockReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddBlockReward == nil {
				m.AddBlockReward = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AddBlockReward[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockIndex == nil {
				m.BlockIndex = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BlockIndex[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessRatio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WitnessRatio == nil {
				m.WitnessRatio = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WitnessRatio[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDistributeHeight", wireType)
			}
			m.LastDistributeHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastDistributeHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessRewardPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WitnessRewardPool == nil {
				m.WitnessRewardPool = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WitnessRewardPool[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityRewardPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommunityRewardPool == nil {
				m.CommunityRewardPool = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CommunityRewardPool[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameNetRewardPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NameNetRewardPool == nil {
				m.NameNetRewardPool = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NameNetRewardPool[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessMapCommunitys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WitnessMapCommunitys == nil {
				m.WitnessMapCommunitys = make(map[string]*Addresses)
			}
			var mapkey string
			var mapvalue *Addresses
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Addresses{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WitnessMapCommunitys[mapkey] = mapvalue
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityMapLights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommunityMapLights == nil {
				m.CommunityMapLights = make(map[string]*Addresses)
			}
			var mapkey string
			var mapvalue *Addresses
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Addresses{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CommunityMapLights[mapkey] = mapvalue
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxAveGas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxAveGas == nil {
				m.TxAveGas = &TxAveGas{}
			}
			if err := m.TxAveGas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastVoteOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastVoteOp == nil {
				m.LastVoteOp = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LastVoteOp[mapkey] = mapvalue
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositWitness", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DepositWitness == nil {
				m.DepositWitness = make(map[string]*DepositInfo)
			}
			var mapkey string
			var mapvalue *DepositInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DepositInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DepositWitness[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddrReward == nil {
				m.AddrReward = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AddrReward[mapkey] = mapvalue
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OtherDeposit == nil {
				m.OtherDeposit = make(map[int64][]byte)
			}
			var mapkey int64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OtherDeposit[mapkey] = mapvalue
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositFreeGas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DepositFreeGas == nil {
				m.DepositFreeGas = make(map[string]*DepositFreeGas)
			}
			var mapkey string
			var mapvalue *DepositFreeGas
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DepositFreeGas{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DepositFreeGas[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Addresses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Addresses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Addresses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, make([]byte, postIndex-iNdEx))
			copy(m.Addresses[len(m.Addresses)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxAveGas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxAveGas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxAveGas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AllGas = append(m.AllGas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSnapshotchain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSnapshotchain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AllGas) == 0 {
					m.AllGas = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AllGas = append(m.AllGas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AllGas", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositFreeGas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositFreeGas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositFreeGas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddresses", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddresses = append(m.ContractAddresses[:0], dAtA[iNdEx:postIndex]...)
			if m.ContractAddresses == nil {
				m.ContractAddresses = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			m.Deposit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deposit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitHeight", wireType)
			}
			m.LimitHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitCount", wireType)
			}
			m.LimitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = append(m.Addr[:0], dAtA[iNdEx:postIndex]...)
			if m.Addr == nil {
				m.Addr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteType", wireType)
			}
			m.VoteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoteType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockupHeight", wireType)
			}
			m.LockupHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockupHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WitnessAddr = append(m.WitnessAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.WitnessAddr == nil {
				m.WitnessAddr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelfAddr = append(m.SelfAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.SelfAddr == nil {
				m.SelfAddr = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotWitnessChain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotWitnessChain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotWitnessChain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessNotGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WitnessNotGroup = append(m.WitnessNotGroup, &SnapshotWitness{})
			if err := m.WitnessNotGroup[len(m.WitnessNotGroup)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllWitnessNotGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllWitnessNotGroup == nil {
				m.AllWitnessNotGroup = make(map[string]*SnapshotWitness)
			}
			var mapkey string
			var mapvalue *SnapshotWitness
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshotchain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshotchain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SnapshotWitness{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshotchain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshotchain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AllWitnessNotGroup[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigGroupNotGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BigGroupNotGroup == nil {
				m.BigGroupNotGroup = &SnapshotWitnessBigGroup{}
			}
			if err := m.BigGroupNotGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigGroup = append(m.BigGroup, &SnapshotWitnessBigGroup{})
			if err := m.BigGroup[len(m.BigGroup)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmallGroup = append(m.SmallGroup, &SnapshotWitnessSmallGroup{})
			if err := m.SmallGroup[len(m.SmallGroup)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = append(m.Group, &SnapshotGroup{})
			if err := m.Group[len(m.Group)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Witness", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Witness = append(m.Witness, &SnapshotWitness{})
			if err := m.Witness[len(m.Witness)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Block = append(m.Block, &SnapshotBlock{})
			if err := m.Block[len(m.Block)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSmallGroupIndex", wireType)
			}
			m.CurrentSmallGroupIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSmallGroupIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotWitnessBigGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotWitnessBigGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotWitnessBigGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Witnesses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Witnesses = append(m.Witnesses, &SnapshotWitness{})
			if err := m.Witnesses[len(m.Witnesses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessBackup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WitnessBackup = append(m.WitnessBackup, &SnapshotWitness{})
			if err := m.WitnessBackup[len(m.WitnessBackup)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotWitnessSmallGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotWitnessSmallGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotWitnessSmallGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Task = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Witness", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Witness = append(m.Witness, &SnapshotWitness{})
			if err := m.Witness[len(m.Witness)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockGroup == nil {
				m.BlockGroup = &SnapshotGroup{}
			}
			if err := m.BlockGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuildGroup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuildGroup = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tag = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCount = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &SnapshotBlock{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotWitness) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotWitness: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotWitness: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = append(m.Addr[:0], dAtA[iNdEx:postIndex]...)
			if m.Addr == nil {
				m.Addr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Puk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Puk = append(m.Puk[:0], dAtA[iNdEx:postIndex]...)
			if m.Puk == nil {
				m.Puk = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &SnapshotBlock{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityVotes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityVotes = append(m.CommunityVotes, &VoteScore{})
			if err := m.CommunityVotes[len(m.CommunityVotes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Votes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Votes = append(m.Votes, &VoteScore{})
			if err := m.Votes[len(m.Votes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteNum", wireType)
			}
			m.VoteNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoteNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBlockTime", wireType)
			}
			m.CreateBlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessBigGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WitnessBigGroup == nil {
				m.WitnessBigGroup = &SnapshotWitnessBigGroup{}
			}
			if err := m.WitnessBigGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckIsMining", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckIsMining = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SignExist = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SleepTime", wireType)
			}
			m.SleepTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SleepTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallGroupHeight", wireType)
			}
			m.SmallGroupHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SmallGroupHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PtrAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PtrAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreBlockID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreBlockID = append(m.PreBlockID[:0], dAtA[iNdEx:postIndex]...)
			if m.PreBlockID == nil {
				m.PreBlockID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCount = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshotchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshotchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSnapshotchain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSnapshotchain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSnapshotchain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSnapshotchain
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSnapshotchain
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSnapshotchain
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSnapshotchain        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSnapshotchain          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSnapshotchain = fmt.Errorf("proto: unexpected end of group")
)
